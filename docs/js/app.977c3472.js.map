{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/App.vue?926f","webpack:///./src/App.vue?515a","webpack:///./src/codegen/config.ts","webpack:///./src/codegen/slices-template.ts","webpack:///./src/codegen/slices-comparable-template.ts","webpack:///./src/codegen/slices-timsort-template.ts","webpack:///./src/codegen/slices-comparable-timsort-template.ts","webpack:///./src/codegen/index.ts","webpack:///./src/components/ConfigPanel.vue?08d8","webpack:///./src/components/ConfigPanel.vue?31cf","webpack:///./src/components/ConfigPanel.vue?5faa","webpack:///./src/components/ConfigPanel.vue","webpack:///./src/App.vue?ec60","webpack:///./src/App.vue?bfbe","webpack:///./src/App.vue","webpack:///./src/registerServiceWorker.ts","webpack:///./src/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","app","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default","render","_vm","this","_h","$createElement","_c","_self","attrs","id","when","padding","model","callback","$$v","config","expression","staticClass","main","color","slot","_v","_s","goCode","staticRenderFns","symbol","notPrivateKeyWord","capitalName","toUpperCase","combinedName","funcPrefix","funcSuffix","toLowerCase","generate","packageName","sliceType","sort","binarySearch","indexOf","contains","insert","remove","iterateOver","merge","lessThan","generateComparable","generateTimsort","newTimSort","reverseRange","minRunLength","countRunAndMakeAscending","iBinarySort","timSortHandler","gallopLeft","gallopRight","generateComparableTimsort","generateSourceCode","source","acceptLessThan","useTimSort","simpleGoFormat","src","_a","split","lines","map","line","match","indent","Math","floor","space","Array","join","tab","replace","ConfigPanelvue_type_template_id_747d5987_render","position","getPackageName","on","ionInput","$event","onChangePackageName","getFunctionPrefix","onChangeFunctionPrefix","getFunctionSuffix","onChangeFunctionSuffix","checked","doesUsePrimitiveType","ionChange","onChangeType","undefined","getSliceType","disabled","onChangeSliceType","getPrimitiveSliceType","okText","cancelText","onChangePrimitiveSliceType","doesAcceptLessThan","onChangeAcceptLessThan","doesUseTimSort","onChangeUseTimSort","ConfigPanelvue_type_template_id_747d5987_staticRenderFns","ConfigPanelvue_type_script_lang_ts_ConfigPanel","_super","ConfigPanel","_this","arguments","pakcageName","functionPrefix","functionSuffix","primitiveSliceType","usePrimitiveType","tslib_es6","event","target","emitConfig","input","vue_property_decorator","ConfigPanelvue_type_script_lang_ts_","components_ConfigPanelvue_type_script_lang_ts_","component","componentNormalizer","components_ConfigPanel","Appvue_type_script_lang_ts_App","App","updated","elem","document","getElementById","innerHTML","escapeHtml","win","Prism","highlightAll","content","components","Appvue_type_script_lang_ts_","src_Appvue_type_script_lang_ts_","App_component","src_App","register_service_worker","ready","console","log","registered","cached","updatefound","offline","error","vue_runtime_esm","productionTip","ignoredElements","h","$mount"],"mappings":"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","file":"js/app.977c3472.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/slices/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('ion-app',[_c('ion-split-pane',{attrs:{\"when\":\"sm\"}},[_c('ion-menu',[_c('ion-content',{attrs:{\"padding\":\"\"}},[_c('ConfigPanel',{model:{value:(_vm.config),callback:function ($$v) {_vm.config=$$v},expression:\"config\"}})],1)],1),_c('ion-page',{staticClass:\"ion-page\",attrs:{\"main\":\"\"}},[_c('ion-header',{attrs:{\"mode\":\"md\"}},[_c('ion-toolbar',{attrs:{\"mode\":\"md\",\"color\":\"primary\"}},[_c('ion-buttons',{attrs:{\"slot\":\"start\"},slot:\"start\"},[_c('ion-menu-toggle',[_c('ion-button',[_c('ion-icon',{attrs:{\"slot\":\"icon-only\",\"name\":\"menu\"},slot:\"icon-only\"})],1)],1)],1),_c('ion-title',[_vm._v(\"Go slice algorithms code generator\")])],1)],1),_c('ion-content',{attrs:{\"padding\":\"\"}},[_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"            \"),_c('code',{staticClass:\"language-go\",attrs:{\"id\":\"goCode\"}},[_vm._v(_vm._s(_vm.goCode()))]),_vm._v(\"\\n          \")])])],1)],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export type GeneratorConfig = {\n    packageName: string;\n    funcPrefix: string;\n    funcSuffix: string;\n    sliceType: string;\n    acceptLessThan: boolean;\n    useTimSort: boolean;\n};\n\n\nexport function symbol(name: string, notPrivateKeyWord: boolean, config: GeneratorConfig): string {\n    const capitalName = name[0].toUpperCase() + name.slice(1);\n    const combinedName = `${config.funcPrefix}${capitalName}${config.funcSuffix}`;\n    if (!notPrivateKeyWord) {\n        return combinedName[0].toLowerCase() + combinedName.slice(1);\n    }\n    return combinedName;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generate(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const merge = symbol('Merge', true, config);\n    const lessThan = symbol('LessThan', true, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"sort\"\n    )\n\n    // ${lessThan} is delegate type that sorting uses as a comparator\n    type ${lessThan} func(a, b ${sliceType}) bool\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}, lt ${lessThan}) (err error) {\n        sort.Slice(a, func(i, j int) bool {\n            return lt(a[i], a[j])\n        })\n        return nil\n    }\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if lt(sorted[h], item) {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) bool {\n        i := ${binarySearch}(sorted, item, lt)\n        return !lt(sorted[i], item) && !lt(item, sorted[i])\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if i == len(sorted) - 1 && lt(sorted[i], item) {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(lt ${lessThan}, callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${merge} merges sorted slices and returns new slices.\n    func ${merge}(lt ${lessThan}, sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if length == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n    `;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generateComparable(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const merge = symbol('Merge', true, config);\n    const lessThan = symbol('LessThan', true, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"sort\"\n    )\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}) (err error) {\n        sort.Slice(a, func(i, j int) bool {\n            return a[i] < a[j]\n        })\n        return nil\n    }\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if sorted[h] < item {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}) int {\n        i := ${binarySearch}(sorted, item, lt)\n        if sorted[i] == item {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}) bool {\n        i := ${binarySearch}(sorted, item, lt)\n        return sorted[i] == item\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if i == len(sorted) - 1 && sorted[i] < item {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if sorted[i] == item {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${merge} merges sorted slices and returns new slices.\n    func ${merge}(sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if length == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n    `;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generateTimsort(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const merge = symbol('Merge', true, config);\n    const lessThan = symbol('LessThan', true, config);\n\n    const newTimSort = symbol('newTimSort', false, config);\n    const reverseRange = symbol('reverseRange', false, config);\n    const minRunLength = symbol('minRunLength', false, config);\n    const countRunAndMakeAscending = symbol('countRunAndMakeAscending', false, config);\n    const iBinarySort = symbol('binarySort', false, config);\n    const timSortHandler = symbol('timSortHandler', false, config);\n    const gallopLeft = symbol('gallopLeft', false, config);\n    const gallopRight = symbol('gallopRight', false, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"errors\"\n        \"fmt\"\n    )\n\n    // ${lessThan} is delegate type that sorting uses as a comparator\n    type ${lessThan} func(a, b ${sliceType}) bool\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if lt(sorted[h], item) {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) bool {\n        i := ${binarySearch}(sorted, item, lt)\n        return !lt(sorted[i], item) && !lt(item, sorted[i])\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if i == len(sorted) - 1 && lt(sorted[i], item) {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(lt ${lessThan}, callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${merge} merges sorted slices and returns new slices.\n    func ${merge}(lt ${lessThan}, sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if length == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n\n    // timsort code is based on https://github.com/psilva261/timsort\n    //\n    // Package timsort provides fast stable sort, uses external comparator.\n    //\n    // A stable, adaptive, iterative mergesort that requires far fewer than\n    // n lg(n) comparisons when running on partially sorted arrays, while\n    // offering performance comparable to a traditional mergesort when run\n    // on random arrays.  Like all proper mergesorts, this sort is stable and\n    // runs O(n log n) time (worst case).  In the worst case, this sort requires\n    // temporary storage space for n/2 object references; in the best case,\n    // it requires only a small constant amount of space.\n    //\n    // This implementation was derived from Java's TimSort object by Josh Bloch,\n    // which, in turn, was based on the original code by Tim Peters:\n    //\n    // http://svn.python.org/projects/python/trunk/Objects/listsort.txt\n    //\n    // Mike K.\n    // ${lessThan} is Delegate type that sorting uses as a comparator\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}, lt ${lessThan}) (err error) {\n        const minMerge = 32\n        lo := 0\n        hi := len(a)\n        nRemaining := hi\n        if nRemaining < 2 {\n            return\n        }\n        if nRemaining < minMerge {\n            initRunLen, err := ${countRunAndMakeAscending}(a, lo, hi, lt)\n            if err != nil {\n                return err\n            }\n            return ${iBinarySort}(a, lo, hi, lo+initRunLen, lt)\n        }\n        ts := ${newTimSort}(a, lt)\n        minRun, err := ${minRunLength}(nRemaining)\n        if err != nil {\n            return\n        }\n        for {\n            runLen, err := ${countRunAndMakeAscending}(a, lo, hi, lt)\n            if err != nil {\n                return err\n            }\n            if runLen < minRun {\n                force := minRun\n                if nRemaining <= minRun {\n                    force = nRemaining\n                }\n                if err = ${iBinarySort}(a, lo, lo+force, lo+runLen, lt); err != nil {\n                    return err\n                }\n                runLen = force\n            }\n            ts.pushRun(lo, runLen)\n            if err = ts.mergeCollapse(); err != nil {\n                return err\n            }\n            lo += runLen\n            nRemaining -= runLen\n            if nRemaining == 0 {\n                break\n            }\n        }\n        if lo != hi {\n            return errors.New(\"lo must equal hi\")\n        }\n        if err = ts.mergeForceCollapse(); err != nil {\n            return\n        }\n        if ts.stackSize != 1 {\n            return errors.New(\"ts.stackSize != 1\")\n        }\n        return\n    }\n\n    type ${timSortHandler} struct {\n        a []${sliceType}\n        lt ${lessThan}\n        minGallop int\n        tmp []${sliceType} // Actual runtime type will be Object[], regardless of ${sliceType}\n        stackSize int // Number of pending runs on stack\n        runBase   []int\n        runLen    []int\n    }\n\n    func ${newTimSort}(a []${sliceType}, lt ${lessThan}) (h *${timSortHandler}) {\n        minGallop := 7\n        initialTmpStorageLength := 256\n        h = new(${timSortHandler})\n\n        h.a = a\n        h.lt = lt\n        h.minGallop = minGallop\n        h.stackSize = 0\n        len := len(a)\n\n        tmpSize := initialTmpStorageLength\n        if len < 2*tmpSize {\n            tmpSize = len / 2\n        }\n\n        h.tmp = make([]${sliceType}, tmpSize)\n        stackLen := 40\n        if len < 120 {\n            stackLen = 5\n        } else if len < 1542 {\n            stackLen = 10\n        } else if len < 119151 {\n            stackLen = 19\n        }\n\n        h.runBase = make([]int, stackLen)\n        h.runLen = make([]int, stackLen)\n\n        return h\n    }\n\n    func ${iBinarySort}(a []${sliceType}, lo, hi, start int, lt ${lessThan}) (err error) {\n        if lo > start || start > hi {\n            return errors.New(\"lo <= start && start <= hi\")\n        }\n\n        if start == lo {\n            start++\n        }\n\n        for ; start < hi; start++ {\n            pivot := a[start]\n            left := lo\n            right := start\n            if left > right {\n                return errors.New(\"left <= right\")\n            }\n            for left < right {\n                mid := int(uint(left+right) >> 1)\n                if lt(pivot, a[mid]) {\n                    right = mid\n                } else {\n                    left = mid + 1\n                }\n            }\n            if left != right {\n                return errors.New(\"left == right\")\n            }\n            n := start - left // The number of elements to move\n            if n <= 2 {\n                if n == 2 {\n                    a[left+2] = a[left+1]\n                }\n                if n > 0 {\n                    a[left+1] = a[left]\n                }\n            } else {\n                copy(a[left+1:], a[left:left+n])\n            }\n            a[left] = pivot\n        }\n        return\n    }\n\n    func ${countRunAndMakeAscending}(a []${sliceType}, lo, hi int, lt ${lessThan}) (int, error) {\n        if lo >= hi {\n            return 0, errors.New(\"lo < hi\")\n        }\n        runHi := lo + 1\n        if runHi == hi {\n            return 1, nil\n        }\n        if lt(a[runHi], a[lo]) {\n            runHi++\n            for runHi < hi && lt(a[runHi], a[runHi-1]) {\n                runHi++\n            }\n            ${reverseRange}(a, lo, runHi)\n        } else {\n            for runHi < hi && !lt(a[runHi], a[runHi-1]) {\n                runHi++\n            }\n        }\n        return runHi - lo, nil\n    }\n\n    func ${reverseRange}(a []${sliceType}, lo, hi int) {\n        hi--\n        for lo < hi {\n            a[lo], a[hi] = a[hi], a[lo]\n            lo++\n            hi--\n        }\n    }\n\n    func ${minRunLength}(n int) (int, error) {\n        const minMerge = 32\n        if n < 0 {\n            return 0, errors.New(\"n >= 0\")\n        }\n        r := 0 // Becomes 1 if any 1 bits are shifted off\n        for n >= minMerge {\n            r |= (n & 1)\n            n >>= 1\n        }\n        return n + r, nil\n    }\n\n    func (h *${timSortHandler}) pushRun(runBase, runLen int) {\n        h.runBase[h.stackSize] = runBase\n        h.runLen[h.stackSize] = runLen\n        h.stackSize++\n    }\n\n    func (h *${timSortHandler}) mergeCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if (n > 0 && h.runLen[n-1] <= h.runLen[n]+h.runLen[n+1]) ||\n                (n > 1 && h.runLen[n-2] <= h.runLen[n-1]+h.runLen[n]) {\n                if h.runLen[n-1] < h.runLen[n+1] {\n                    n--\n                }\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else if h.runLen[n] <= h.runLen[n+1] {\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else {\n                break\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeForceCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if n > 0 && h.runLen[n-1] < h.runLen[n+1] {\n                n--\n            }\n            if err = h.mergeAt(n); err != nil {\n                return\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeAt(i int) (err error) {\n        if h.stackSize < 2 {\n            return errors.New(\"stackSize >= 2\")\n        }\n        if i < 0 {\n            return errors.New(\" i >= 0\")\n        }\n        if i != h.stackSize-2 && i != h.stackSize-3 {\n            return errors.New(\"if i == stackSize - 2 || i == stackSize - 3\")\n        }\n        base1 := h.runBase[i]\n        len1 := h.runLen[i]\n        base2 := h.runBase[i+1]\n        len2 := h.runLen[i+1]\n        if len1 <= 0 || len2 <= 0 {\n            return errors.New(\"len1 > 0 && len2 > 0\")\n        }\n        if base1+len1 != base2 {\n            return errors.New(\"base1 + len1 == base2\")\n        }\n        h.runLen[i] = len1 + len2\n        if i == h.stackSize-3 {\n            h.runBase[i+1] = h.runBase[i+2]\n            h.runLen[i+1] = h.runLen[i+2]\n        }\n        h.stackSize--\n        k, err := ${gallopRight}(h.a[base2], h.a, base1, len1, 0, h.lt)\n        if err != nil {\n            return err\n        }\n        if k < 0 {\n            return errors.New(\" k >= 0;\")\n        }\n        base1 += k\n        len1 -= k\n        if len1 == 0 {\n            return\n        }\n        len2, err = ${gallopLeft}(h.a[base1+len1-1], h.a, base2, len2, len2-1, h.lt)\n        if err != nil {\n            return\n        }\n        if len2 < 0 {\n            return errors.New(\" len2 >= 0;\")\n        }\n        if len2 == 0 {\n            return\n        }\n        if len1 <= len2 {\n            err = h.mergeLo(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeLo: %v\", err)\n            }\n        } else {\n            err = h.mergeHi(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeHi: %v\", err)\n            }\n        }\n        return\n    }\n\n    func ${gallopLeft}(key ${sliceType}, a []${sliceType}, base, len, hint int, c ${lessThan}) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n        lastOfs := 0\n        ofs := 1\n\n        if c(a[base+hint], key) {\n            maxOfs := len - hint\n            for ofs < maxOfs && c(a[base+hint+ofs], key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        } else {\n            maxOfs := hint + 1\n            for ofs < maxOfs && !c(a[base+hint-ofs], key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\" -1 <= lastOfs && lastOfs < ofs && ofs <= len;\")\n        }\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if c(a[base+m], key) {\n                lastOfs = m + 1\n            } else {\n                ofs = m\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\")\n        }\n        return ofs, nil\n    }\n\n    func ${gallopRight}(key ${sliceType}, a []${sliceType}, base, len, hint int, c ${lessThan}) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n\n        ofs := 1\n        lastOfs := 0\n        if c(key, a[base+hint]) {\n            maxOfs := hint + 1\n            for ofs < maxOfs && c(key, a[base+hint-ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        } else {\n            maxOfs := len - hint\n            for ofs < maxOfs && !c(key, a[base+hint+ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\"-1 <= lastOfs && lastOfs < ofs && ofs <= len\")\n        }\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if c(key, a[base+m]) {\n                ofs = m\n            } else {\n                lastOfs = m + 1\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\")\n        }\n        return ofs, nil\n    }\n\n    func (h *${timSortHandler}) mergeLo(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\" len1 > 0 && len2 > 0 && base1 + len1 == base2\")\n        }\n        a := h.a\n        tmp := h.ensureCapacity(len1)\n        copy(tmp, a[base1:base1+len1])\n        cursor1 := 0\n        cursor2 := base2\n        dest := base1\n        a[dest] = a[cursor2]\n        dest++\n        cursor2++\n        len2--\n        if len2 == 0 {\n            copy(a[dest:dest+len1], tmp)\n            return\n        }\n        if len1 == 1 {\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1]\n            return\n        }\n        lt := h.lt\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0\n            count2 := 0\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\" len1 > 1 && len2 > 0\")\n                }\n\n                if lt(a[cursor2], tmp[cursor1]) {\n                    a[dest] = a[cursor2]\n                    dest++\n                    cursor2++\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor1]\n                    dest++\n                    cursor1++\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\"len1 > 1 && len2 > 0\")\n                }\n                count1, err = ${gallopRight}(a[cursor2], tmp, cursor1, len1, 0, lt)\n                if err != nil {\n                    return\n                }\n                if count1 != 0 {\n                    copy(a[dest:dest+count1], tmp[cursor1:cursor1+count1])\n                    dest += count1\n                    cursor1 += count1\n                    len1 -= count1\n                    if len1 <= 1 {\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor2]\n                dest++\n                cursor2++\n                len2--\n                if len2 == 0 {\n                    break outer\n                }\n                count2, err = ${gallopLeft}(tmp[cursor1], a, cursor2, len2, 0, lt)\n                if err != nil {\n                    return\n                }\n                if count2 != 0 {\n                    copy(a[dest:dest+count2], a[cursor2:cursor2+count2])\n                    dest += count2\n                    cursor2 += count2\n                    len2 -= count2\n                    if len2 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor1]\n                dest++\n                cursor1++\n                len1--\n                if len1 == 1 {\n                    break outer\n                }\n                minGallop--\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2\n        }\n        if minGallop < 1 {\n            minGallop = 1\n        }\n        h.minGallop = minGallop\n        if len1 == 1 {\n\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1]\n        } else if len1 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len2 != 0 {\n                return errors.New(\"len2 == 0;\")\n            }\n            if len1 <= 1 {\n                return errors.New(\" len1 > 1;\")\n            }\n            copy(a[dest:dest+len1], tmp[cursor1:cursor1+len1])\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeHi(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\"len1 > 0 && len2 > 0 && base1 + len1 == base2;\")\n        }\n        a := h.a\n        tmp := h.ensureCapacity(len2)\n        copy(tmp, a[base2:base2+len2])\n        cursor1 := base1 + len1 - 1\n        cursor2 := len2 - 1\n        dest := base2 + len2 - 1\n        a[dest] = a[cursor1]\n        dest--\n        cursor1--\n        len1--\n        if len1 == 0 {\n            dest -= len2 - 1\n            copy(a[dest:dest+len2], tmp)\n            return\n        }\n        if len2 == 1 {\n            dest -= len1 - 1\n            cursor1 -= len1 - 1\n            copy(a[dest:dest+len1], a[cursor1:cursor1+len1])\n            a[dest-1] = tmp[cursor2]\n            return\n        }\n        lt := h.lt\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if lt(tmp[cursor2], a[cursor1]) {\n                    a[dest] = a[cursor1]\n                    dest--\n                    cursor1--\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor2]\n                    dest--\n                    cursor2--\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if gr, err := ${gallopRight}(tmp[cursor2], a, base1, len1, len1-1, lt); err == nil {\n                    count1 = len1 - gr\n                } else {\n                    return err\n                }\n                if count1 != 0 {\n                    dest -= count1\n                    cursor1 -= count1\n                    len1 -= count1\n                    copy(a[dest+1:dest+1+count1], a[cursor1+1:cursor1+1+count1])\n                    if len1 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor2]\n                dest--\n                cursor2--\n                len2--\n                if len2 == 1 {\n                    break outer\n                }\n\n                if gl, err := ${gallopLeft}(a[cursor1], tmp, 0, len2, len2-1, lt); err == nil {\n                    count2 = len2 - gl\n                } else {\n                    return err\n                }\n                if count2 != 0 {\n                    dest -= count2\n                    cursor2 -= count2\n                    len2 -= count2\n                    copy(a[dest+1:dest+1+count2], tmp[cursor2+1:cursor2+1+count2])\n                    if len2 <= 1 { // len2 == 1 || len2 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor1]\n                dest--\n                cursor1--\n                len1--\n                if len1 == 0 {\n                    break outer\n                }\n                minGallop--\n\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        } // End of \"outer\" loop\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n\n        h.minGallop = minGallop // Write back to field\n\n        if len2 == 1 {\n            if len1 <= 0 {\n                return errors.New(\" len1 > 0;\")\n            }\n            dest -= len1\n            cursor1 -= len1\n\n            copy(a[dest+1:dest+1+len1], a[cursor1+1:cursor1+1+len1])\n            a[dest] = tmp[cursor2] // Move first elt of run2 to front of merge\n        } else if len2 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len1 != 0 {\n                return errors.New(\"len1 == 0;\")\n            }\n\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n\n            copy(a[dest-(len2-1):dest+1], tmp)\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) ensureCapacity(minCapacity int) []${sliceType} {\n        if len(h.tmp) < minCapacity {\n            // Compute smallest power of 2 > minCapacity\n            newSize := minCapacity\n            newSize |= newSize >> 1\n            newSize |= newSize >> 2\n            newSize |= newSize >> 4\n            newSize |= newSize >> 8\n            newSize |= newSize >> 16\n            newSize++\n\n            if newSize < 0 { // Not bloody likely!\n                newSize = minCapacity\n            } else {\n                ns := len(h.a) / 2\n                if ns < newSize {\n                    newSize = ns\n                }\n            }\n\n            h.tmp = make([]${sliceType}, newSize)\n        }\n\n        return h.tmp\n    }\n    `;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generateComparableTimsort(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const merge = symbol('Merge', true, config);\n\n    const countRunAndMakeAscending = symbol('countRunAndMakeAscending', false, config);\n    const reverseRange = symbol('reverseRange', false, config);\n    const minRunLength = symbol('minRunLength', false, config);\n    const iBinarySort = symbol('binarySort', false, config);\n    const timSortHandler = symbol('timSortHandler', false, config);\n    const gallopLeft = symbol('gallopLeft', false, config);\n    const gallopRight = symbol('gallopRight', false, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"errors\"\n        \"fmt\"\n    )\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if sorted[h] < item {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}) int {\n        i := ${binarySearch}(sorted, item)\n        if sorted[i] == item {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}) bool {\n        i := ${binarySearch}(sorted, item)\n        return sorted[i] == item\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item)\n        if i == len(sorted) - 1 && sorted[i] < item {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item)\n        if sorted[i] == item {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${merge} merges sorted slices and returns new slices.\n    func ${merge}(sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if length == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n\n    // timsort code is based on https://github.com/psilva261/timsort\n    //\n    // Package timsort provides fast stable sort, uses external comparator.\n    //\n    // A stable, adaptive, iterative mergesort that requires far fewer than\n    // n lg(n) comparisons when running on partially sorted arrays, while\n    // offering performance comparable to a traditional mergesort when run\n    // on random arrays.  Like all proper mergesorts, this sort is stable and\n    // runs O(n log n) time (worst case).  In the worst case, this sort requires\n    // temporary storage space for n/2 object references; in the best case,\n    // it requires only a small constant amount of space.\n    //\n    // This implementation was derived from Java's TimSort object by Josh Bloch,\n    // which, in turn, was based on the original code by Tim Peters:\n    //\n    // http://svn.python.org/projects/python/trunk/Objects/listsort.txt\n    //\n    // Mike K.\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}) (err error) {\n        minMerge := 32\n        lo := 0\n        hi := len(a)\n        nRemaining := hi\n\n        if nRemaining < 2 {\n            return // Arrays of size 0 and 1 are always sorted\n        }\n\n        if nRemaining < minMerge {\n            initRunLen, err := ${countRunAndMakeAscending}(a, lo, hi)\n            if err != nil {\n                return err\n            }\n            return ${iBinarySort}(a, lo, hi, lo+initRunLen)\n        }\n        ts := ${symbol('newTimSort', false, config)}(a)\n        minRun, err := ${minRunLength}(nRemaining)\n        if err != nil {\n            return\n        }\n        for {\n            // Identify next run\n            runLen, err := ${countRunAndMakeAscending}(a, lo, hi)\n            if err != nil {\n                return err\n            }\n            if runLen < minRun {\n                force := minRun\n                if nRemaining <= minRun {\n                    force = nRemaining\n                }\n                if err = ${iBinarySort}(a, lo, lo+force, lo+runLen); err != nil {\n                    return err\n                }\n                runLen = force\n            }\n            ts.pushRun(lo, runLen)\n            if err = ts.mergeCollapse(); err != nil {\n                return err\n            }\n            lo += runLen\n            nRemaining -= runLen\n            if nRemaining == 0 {\n                break\n            }\n        }\n        if lo != hi {\n            return errors.New(\"lo must equal hi\")\n        }\n        if err = ts.mergeForceCollapse(); err != nil {\n            return\n        }\n        if ts.stackSize != 1 {\n            return errors.New(\"ts.stackSize != 1\")\n        }\n        return\n    }\n\n    type ${timSortHandler} struct {\n        a []${sliceType}\n        minGallop int\n        tmp []${sliceType}\n        stackSize int\n        runBase   []int\n        runLen    []int\n    }\n\n    func ${symbol('newTimSort', false, config)}(a []${sliceType}) (h *${timSortHandler}) {\n        minGallop := 7\n        initialTmpStorageLength := 256\n        h = new(${timSortHandler})\n\n        h.a = a\n        h.minGallop = minGallop\n        h.stackSize = 0\n        len := len(a)\n        tmpSize := initialTmpStorageLength\n        if len < 2*tmpSize {\n            tmpSize = len / 2\n        }\n        h.tmp = make([]${sliceType}, tmpSize)\n        stackLen := 40\n        if len < 120 {\n            stackLen = 5\n        } else if len < 1542 {\n            stackLen = 10\n        } else if len < 119151 {\n            stackLen = 19\n        }\n        h.runBase = make([]int, stackLen)\n        h.runLen = make([]int, stackLen)\n        return h\n    }\n\n    func ${iBinarySort}(a []${sliceType}, lo, hi, start int) (err error) {\n        if lo > start || start > hi {\n            return errors.New(\"lo <= start && start <= hi\")\n        }\n        if start == lo {\n            start++\n        }\n        for ; start < hi; start++ {\n            pivot := a[start]\n            left := lo\n            right := start\n            if left > right {\n                return errors.New(\"left <= right\")\n            }\n            for left < right {\n                mid := int(uint(left+right) >> 1)\n                if pivot < a[mid] {\n                    right = mid\n                } else {\n                    left = mid + 1\n                }\n            }\n            if left != right {\n                return errors.New(\"left == right\")\n            }\n            n := start - left // The number of elements to move\n            // just an optimization for copy in default case\n            if n <= 2 {\n                if n == 2 {\n                    a[left+2] = a[left+1]\n                }\n                if n > 0 {\n                    a[left+1] = a[left]\n                }\n            } else {\n                copy(a[left+1:], a[left:left+n])\n            }\n            a[left] = pivot\n        }\n        return\n    }\n\n    func ${countRunAndMakeAscending}(a []${sliceType}, lo, hi int) (int, error) {\n        if lo >= hi {\n            return 0, errors.New(\"lo < hi\")\n        }\n        runHi := lo + 1\n        if runHi == hi {\n            return 1, nil\n        }\n        if a[runHi] < a[lo] { // Descending\n            runHi++\n            for runHi < hi && a[runHi] < a[runHi-1] {\n                runHi++\n            }\n            ${reverseRange}(a, lo, runHi)\n        } else { // Ascending\n            for runHi < hi && !(a[runHi] < a[runHi-1]) {\n                runHi++\n            }\n        }\n        return runHi - lo, nil\n    }\n\n    func ${reverseRange}(a []${sliceType}, lo, hi int) {\n        hi--\n        for lo < hi {\n            a[lo], a[hi] = a[hi], a[lo]\n            lo++\n            hi--\n        }\n    }\n\n    func ${minRunLength}(n int) (int, error) {\n        minMerge := 32\n        if n < 0 {\n            return 0, errors.New(\"n >= 0\")\n        }\n        r := 0 // Becomes 1 if any 1 bits are shifted off\n        for n >= minMerge {\n            r |= (n & 1)\n            n >>= 1\n        }\n        return n + r, nil\n    }\n\n    func (h *${timSortHandler}) pushRun(runBase, runLen int) {\n        h.runBase[h.stackSize] = runBase\n        h.runLen[h.stackSize] = runLen\n        h.stackSize++\n    }\n\n    func (h *${timSortHandler}) mergeCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if (n > 0 && h.runLen[n-1] <= h.runLen[n]+h.runLen[n+1]) ||\n                (n > 1 && h.runLen[n-2] <= h.runLen[n-1]+h.runLen[n]) {\n                if h.runLen[n-1] < h.runLen[n+1] {\n                    n--\n                }\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else if h.runLen[n] <= h.runLen[n+1] {\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else {\n                break // Invariant is established\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeForceCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if n > 0 && h.runLen[n-1] < h.runLen[n+1] {\n                n--\n            }\n            if err = h.mergeAt(n); err != nil {\n                return\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeAt(i int) (err error) {\n        if h.stackSize < 2 {\n            return errors.New(\"stackSize >= 2\")\n        }\n\n        if i < 0 {\n            return errors.New(\" i >= 0\")\n        }\n\n        if i != h.stackSize-2 && i != h.stackSize-3 {\n            return errors.New(\"if i == stackSize - 2 || i == stackSize - 3\")\n        }\n\n        base1 := h.runBase[i]\n        len1 := h.runLen[i]\n        base2 := h.runBase[i+1]\n        len2 := h.runLen[i+1]\n\n        if len1 <= 0 || len2 <= 0 {\n            return errors.New(\"len1 > 0 && len2 > 0\")\n        }\n\n        if base1+len1 != base2 {\n            return errors.New(\"base1 + len1 == base2\")\n        }\n\n        h.runLen[i] = len1 + len2\n        if i == h.stackSize-3 {\n            h.runBase[i+1] = h.runBase[i+2]\n            h.runLen[i+1] = h.runLen[i+2]\n        }\n        h.stackSize--\n\n        k, err := ${gallopRight}(h.a[base2], h.a, base1, len1, 0)\n        if err != nil {\n            return err\n        }\n        if k < 0 {\n            return errors.New(\" k >= 0;\")\n        }\n        base1 += k\n        len1 -= k\n        if len1 == 0 {\n            return\n        }\n\n        len2, err = ${gallopLeft}(h.a[base1+len1-1], h.a, base2, len2, len2-1)\n        if err != nil {\n            return\n        }\n        if len2 < 0 {\n            return errors.New(\" len2 >= 0;\")\n        }\n        if len2 == 0 {\n            return\n        }\n\n        if len1 <= len2 {\n            err = h.mergeLo(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeLo: %v\", err)\n            }\n        } else {\n            err = h.mergeHi(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeHi: %v\", err)\n            }\n        }\n        return\n    }\n\n    func ${gallopLeft}(key ${sliceType}, a []${sliceType}, base, len, hint int) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n        lastOfs := 0\n        ofs := 1\n\n        if a[base+hint] < key {\n            // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]\n            maxOfs := len - hint\n            for ofs < maxOfs && a[base+hint+ofs] < key {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        } else { // key <= a[base + hint]\n            // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]\n            maxOfs := hint + 1\n            for ofs < maxOfs && !(a[base+hint-ofs] < key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        }\n\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\" -1 <= lastOfs && lastOfs < ofs && ofs <= len;\")\n        }\n\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n            if a[base+m] < key {\n                lastOfs = m + 1 // a[base + m] < key\n            } else {\n                ofs = m // key <= a[base + m]\n            }\n        }\n\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\") // so a[base + ofs - 1] < key <= a[base + ofs]\n        }\n        return ofs, nil\n    }\n\n    func ${gallopRight}(key ${sliceType}, a []${sliceType}, base, len, hint int) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n        ofs := 1\n        lastOfs := 0\n        if key < a[base+hint] {\n            // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]\n            maxOfs := hint + 1\n            for ofs < maxOfs && key < a[base+hint-ofs] {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        } else { // a[b + hint] <= key\n            // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]\n            maxOfs := len - hint\n            for ofs < maxOfs && !(key < a[base+hint+ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n\n            lastOfs += hint\n            ofs += hint\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\"-1 <= lastOfs && lastOfs < ofs && ofs <= len\")\n        }\n\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if key < a[base+m] {\n                ofs = m // key < a[b + m]\n            } else {\n                lastOfs = m + 1 // a[b + m] <= key\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\") // so a[b + ofs - 1] <= key < a[b + ofs]\n        }\n        return ofs, nil\n    }\n\n    func (h *${timSortHandler}) mergeLo(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\" len1 > 0 && len2 > 0 && base1 + len1 == base2\")\n        }\n\n        a := h.a // For performance\n        tmp := h.ensureCapacity(len1)\n\n        copy(tmp, a[base1:base1+len1])\n\n        cursor1 := 0     // Indexes into tmp array\n        cursor2 := base2 // Indexes int a\n        dest := base1    // Indexes int a\n\n        a[dest] = a[cursor2]\n        dest++\n        cursor2++\n        len2--\n        if len2 == 0 {\n            copy(a[dest:dest+len1], tmp)\n            return\n        }\n        if len1 == 1 {\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1] // Last elt of run 1 to end of merge\n            return\n        }\n\n        minGallop := h.minGallop\n\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\" len1 > 1 && len2 > 0\")\n                }\n\n                if a[cursor2] < tmp[cursor1] {\n                    a[dest] = a[cursor2]\n                    dest++\n                    cursor2++\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor1]\n                    dest++\n                    cursor1++\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\"len1 > 1 && len2 > 0\")\n                }\n                count1, err = ${gallopRight}(a[cursor2], tmp, cursor1, len1, 0)\n                if err != nil {\n                    return\n                }\n                if count1 != 0 {\n                    copy(a[dest:dest+count1], tmp[cursor1:cursor1+count1])\n                    dest += count1\n                    cursor1 += count1\n                    len1 -= count1\n                    if len1 <= 1 { // len1 == 1 || len1 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor2]\n                dest++\n                cursor2++\n                len2--\n                if len2 == 0 {\n                    break outer\n                }\n\n                count2, err = ${gallopLeft}(tmp[cursor1], a, cursor2, len2, 0)\n                if err != nil {\n                    return\n                }\n                if count2 != 0 {\n                    copy(a[dest:dest+count2], a[cursor2:cursor2+count2])\n                    dest += count2\n                    cursor2 += count2\n                    len2 -= count2\n                    if len2 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor1]\n                dest++\n                cursor1++\n                len1--\n                if len1 == 1 {\n                    break outer\n                }\n                minGallop--\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        }\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n        h.minGallop = minGallop // Write back to field\n\n        if len1 == 1 {\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1] //  Last elt of run 1 to end of merge\n        } else if len1 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len2 != 0 {\n                return errors.New(\"len2 == 0;\")\n            }\n            if len1 <= 1 {\n                return errors.New(\" len1 > 1;\")\n            }\n\n            copy(a[dest:dest+len1], tmp[cursor1:cursor1+len1])\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeHi(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\"len1 > 0 && len2 > 0 && base1 + len1 == base2;\")\n        }\n\n        a := h.a // For performance\n        tmp := h.ensureCapacity(len2)\n\n        copy(tmp, a[base2:base2+len2])\n\n        cursor1 := base1 + len1 - 1 // Indexes into a\n        cursor2 := len2 - 1         // Indexes into tmp array\n        dest := base2 + len2 - 1    // Indexes into a\n\n        a[dest] = a[cursor1]\n        dest--\n        cursor1--\n        len1--\n        if len1 == 0 {\n            dest -= len2 - 1\n            copy(a[dest:dest+len2], tmp)\n            return\n        }\n        if len2 == 1 {\n            dest -= len1 - 1\n            cursor1 -= len1 - 1\n            copy(a[dest:dest+len1], a[cursor1:cursor1+len1])\n            a[dest-1] = tmp[cursor2]\n            return\n        }\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if tmp[cursor2] < a[cursor1] {\n                    a[dest] = a[cursor1]\n                    dest--\n                    cursor1--\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor2]\n                    dest--\n                    cursor2--\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if gr, err := ${gallopRight}(tmp[cursor2], a, base1, len1, len1-1); err == nil {\n                    count1 = len1 - gr\n                } else {\n                    return err\n                }\n                if count1 != 0 {\n                    dest -= count1\n                    cursor1 -= count1\n                    len1 -= count1\n                    copy(a[dest+1:dest+1+count1], a[cursor1+1:cursor1+1+count1])\n                    if len1 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor2]\n                dest--\n                cursor2--\n                len2--\n                if len2 == 1 {\n                    break outer\n                }\n\n                if gl, err := ${gallopLeft}(a[cursor1], tmp, 0, len2, len2-1); err == nil {\n                    count2 = len2 - gl\n                } else {\n                    return err\n                }\n                if count2 != 0 {\n                    dest -= count2\n                    cursor2 -= count2\n                    len2 -= count2\n                    copy(a[dest+1:dest+1+count2], tmp[cursor2+1:cursor2+1+count2])\n                    if len2 <= 1 { // len2 == 1 || len2 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor1]\n                dest--\n                cursor1--\n                len1--\n                if len1 == 0 {\n                    break outer\n                }\n                minGallop--\n\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        } // End of \"outer\" loop\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n\n        h.minGallop = minGallop // Write back to field\n\n        if len2 == 1 {\n            if len1 <= 0 {\n                return errors.New(\" len1 > 0;\")\n            }\n            dest -= len1\n            cursor1 -= len1\n\n            copy(a[dest+1:dest+1+len1], a[cursor1+1:cursor1+1+len1])\n            a[dest] = tmp[cursor2] // Move first elt of run2 to front of merge\n        } else if len2 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len1 != 0 {\n                return errors.New(\"len1 == 0;\")\n            }\n\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n\n            copy(a[dest-(len2-1):dest+1], tmp)\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) ensureCapacity(minCapacity int) []${sliceType} {\n        if len(h.tmp) < minCapacity {\n            // Compute smallest power of 2 > minCapacity\n            newSize := minCapacity\n            newSize |= newSize >> 1\n            newSize |= newSize >> 2\n            newSize |= newSize >> 4\n            newSize |= newSize >> 8\n            newSize |= newSize >> 16\n            newSize++\n\n            if newSize < 0 { // Not bloody likely!\n                newSize = minCapacity\n            } else {\n                ns := len(h.a) / 2\n                if ns < newSize {\n                    newSize = ns\n                }\n            }\n\n            h.tmp = make([]${sliceType}, newSize)\n        }\n        return h.tmp\n    }\n    `;\n}\n","import { GeneratorConfig } from './config';\nimport { generate } from './slices-template';\nimport { generateComparable } from './slices-comparable-template';\nimport { generateTimsort } from './slices-timsort-template';\nimport { generateComparableTimsort } from './slices-comparable-timsort-template';\n\nexport { GeneratorConfig } from './config';\n\nexport function generateSourceCode(config: GeneratorConfig): string {\n    let source: string;\n    if (config.acceptLessThan) {\n        if (config.useTimSort) {\n            source = generateTimsort(config);\n        } else {\n            source = generate(config);\n        }\n    } else {\n        if (config.useTimSort) {\n            source = generateComparableTimsort(config);\n        } else {\n            source = generateComparable(config);\n        }\n    }\n    return simpleGoFormat(source);\n}\n\nfunction simpleGoFormat(src: string): string {\n    const [_, ...lines] = src.split('\\n');\n\n    const result = lines.map((line: string) => {\n        line = line.slice(4);\n        const match = line.match(/^( +)/);\n        if (match) {\n            const indent = Math.floor(match[1].length / 4);\n            const space = new Array(indent + 1).join('    ');\n            const tab = new Array(indent + 1).join('\\t');\n            line = line.replace(space, tab);\n        }\n        return line;\n    });\n\n    return result.join('\\n');\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ion-list',[_c('ion-item-group',[_c('ion-list-header',[_c('ion-label',[_vm._v(\"Package/File information\")])],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\"}},[_vm._v(\"Package Name\")]),_c('ion-input',{attrs:{\"value\":_vm.getPackageName},on:{\"ionInput\":function($event){return _vm.onChangePackageName($event)}}})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\"}},[_vm._v(\"Function Prefix\")]),_c('ion-input',{attrs:{\"value\":_vm.getFunctionPrefix},on:{\"ionInput\":function($event){return _vm.onChangeFunctionPrefix($event)}}})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\"}},[_vm._v(\"Function Suffix\")]),_c('ion-input',{attrs:{\"value\":_vm.getFunctionSuffix},on:{\"ionInput\":function($event){return _vm.onChangeFunctionSuffix($event)}}})],1)],1),_c('ion-item-group',[_c('ion-list-header',[_c('ion-label',[_vm._v(\"Generator Option\")])],1),_c('ion-item',[_c('ion-label',[_vm._v(\"Use Primitive Type\")]),_c('ion-toggle',{attrs:{\"slot\":\"end\",\"color\":\"primary\",\"checked\":_vm.doesUsePrimitiveType},on:{\"ionChange\":function($event){return _vm.onChangeType($event)}},slot:\"end\"})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\",\"color\":_vm.doesUsePrimitiveType ? 'medium' : undefined}},[_vm._v(\"Slice Types\")]),_c('ion-input',{attrs:{\"value\":_vm.getSliceType,\"disabled\":_vm.doesUsePrimitiveType},on:{\"ionChange\":function($event){return _vm.onChangeSliceType($event)}}})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\",\"color\":!_vm.doesUsePrimitiveType ? 'medium' : undefined}},[_vm._v(\"Primitive Type\")]),_c('ion-select',{attrs:{\"value\":_vm.getPrimitiveSliceType,\"okText\":\"Okay\",\"cancelText\":\"Dismiss\",\"disabled\":!_vm.doesUsePrimitiveType},on:{\"ionChange\":function($event){return _vm.onChangePrimitiveSliceType($event)}}},[_c('ion-select-option',{attrs:{\"value\":\"int\"}},[_vm._v(\"int\")]),_c('ion-select-option',{attrs:{\"value\":\"uint\"}},[_vm._v(\"uint\")]),_c('ion-select-option',{attrs:{\"value\":\"byte\"}},[_vm._v(\"byte\")]),_c('ion-select-option',{attrs:{\"value\":\"rune\"}},[_vm._v(\"rune\")]),_c('ion-select-option',{attrs:{\"value\":\"int8\"}},[_vm._v(\"int8\")]),_c('ion-select-option',{attrs:{\"value\":\"uint8\"}},[_vm._v(\"uint8\")]),_c('ion-select-option',{attrs:{\"value\":\"int16\"}},[_vm._v(\"int16\")]),_c('ion-select-option',{attrs:{\"value\":\"uint16\"}},[_vm._v(\"uint16\")]),_c('ion-select-option',{attrs:{\"value\":\"int32\"}},[_vm._v(\"int32\")]),_c('ion-select-option',{attrs:{\"value\":\"uint32\"}},[_vm._v(\"uint32\")]),_c('ion-select-option',{attrs:{\"value\":\"int64\"}},[_vm._v(\"int64\")]),_c('ion-select-option',{attrs:{\"value\":\"uint64\"}},[_vm._v(\"uint64\")]),_c('ion-select-option',{attrs:{\"value\":\"float32\"}},[_vm._v(\"float32\")]),_c('ion-select-option',{attrs:{\"value\":\"float64\"}},[_vm._v(\"float64\")])],1)],1),_c('ion-item',[_c('ion-label',[_vm._v(\"Accept LessThan function\")]),_c('ion-toggle',{attrs:{\"slot\":\"end\",\"checked\":_vm.doesAcceptLessThan,\"color\":\"primary\"},on:{\"ionChange\":function($event){return _vm.onChangeAcceptLessThan($event)}},slot:\"end\"})],1),_c('ion-item',[_c('ion-label',[_vm._v(\"Use TimSort\")]),_c('ion-toggle',{attrs:{\"slot\":\"end\",\"color\":\"primary\",\"checked\":_vm.doesUseTimSort},on:{\"ionChange\":function($event){return _vm.onChangeUseTimSort($event)}},slot:\"end\"})],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Emit } from 'vue-property-decorator';\nimport { GeneratorConfig } from '../codegen';\n\n@Component\nexport default class ConfigPanel extends Vue {\n  @Prop() public value!: GeneratorConfig;\n\n  private pakcageName = this.value.packageName;\n  private functionPrefix = this.value.funcPrefix;\n  private functionSuffix = this.value.funcSuffix;\n  private sliceType = this.value.sliceType;\n  private primitiveSliceType = 'int';\n  private usePrimitiveType = false;\n  private acceptLessThan = this.value.acceptLessThan;\n  private useTimSort = this.value.useTimSort;\n\n  get getPackageName(): string {\n    return this.pakcageName;\n  }\n\n  get getFunctionPrefix(): string {\n    return this.functionPrefix;\n  }\n\n  get getFunctionSuffix(): string {\n    return this.functionSuffix;\n  }\n\n  get getSliceType(): string {\n    return this.sliceType;\n  }\n\n  get doesUsePrimitiveType(): boolean {\n    return this.usePrimitiveType;\n  }\n\n  get getPrimitiveSliceType(): string {\n    return this.primitiveSliceType;\n  }\n\n  get doesAcceptLessThan(): boolean {\n    return this.acceptLessThan;\n  }\n\n  get doesUseTimSort(): boolean {\n    return this.useTimSort;\n  }\n\n  public onChangePackageName(event: any) {\n    this.pakcageName = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeFunctionPrefix(event: any) {\n    this.functionPrefix = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeFunctionSuffix(event: any) {\n    this.functionSuffix = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeType(event: any) {\n    this.usePrimitiveType = event.target.checked;\n    this.emitConfig();\n  }\n\n  public onChangeSliceType(event: any) {\n    this.sliceType = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangePrimitiveSliceType(event: any) {\n    this.primitiveSliceType = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeAcceptLessThan(event: any) {\n    this.acceptLessThan = event.target.checked;\n    this.emitConfig();\n  }\n\n  public onChangeUseTimSort(event: any) {\n    this.useTimSort = event.target.checked;\n    this.emitConfig();\n  }\n\n  @Emit()\n  public input(value: GeneratorConfig) {\n  }\n\n  private emitConfig() {\n    const sliceType = this.usePrimitiveType ? this.primitiveSliceType : this.sliceType;\n    const config = {\n      packageName: this.pakcageName,\n      funcPrefix: this.functionPrefix,\n      funcSuffix: this.functionSuffix,\n      sliceType,\n      acceptLessThan: this.acceptLessThan,\n      useTimSort: this.useTimSort,\n    };\n    this.input(config);\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/ts-loader/index.js??ref--12-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConfigPanel.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/ts-loader/index.js??ref--12-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConfigPanel.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ConfigPanel.vue?vue&type=template&id=747d5987&\"\nimport script from \"./ConfigPanel.vue?vue&type=script&lang=ts&\"\nexport * from \"./ConfigPanel.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Emit } from 'vue-property-decorator';\nimport { generateSourceCode, GeneratorConfig } from './codegen';\n\nimport ConfigPanel from './components/ConfigPanel.vue';\n\n@Component({\n  components: {\n    ConfigPanel,\n  },\n})\nexport default class App extends Vue {\n  private config: GeneratorConfig = {\n    packageName: 'main',\n    funcPrefix: 'MyStruct',\n    funcSuffix: '',\n    sliceType: '*MyStruct',\n    acceptLessThan: true,\n    useTimSort: false,\n  };\n\n  private goCode(): string {\n    return generateSourceCode(this.config);\n  }\n\n  private updated() {\n    const elem = document.getElementById('goCode') as HTMLElement;\n    elem.innerHTML = this.escapeHtml(this.goCode());\n    const win = window as any;\n    win.Prism.highlightAll();\n  }\n\n  private escapeHtml(content: string) {\n    return content\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;');\n  }\n}\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/ts-loader/index.js??ref--12-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/ts-loader/index.js??ref--12-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=7bb58f88&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","/* tslint:disable:no-console */\n\nimport { register } from 'register-service-worker';\n\nif (process.env.NODE_ENV === 'production') {\n  register(`${process.env.BASE_URL}service-worker.js`, {\n    ready() {\n      console.log(\n        'App is being served from cache by a service worker.\\n' +\n        'For more details, visit https://goo.gl/AFskqB',\n      );\n    },\n    registered() {\n      console.log('Service worker has been registered.');\n    },\n    cached() {\n      console.log('Content has been cached for offline use.');\n    },\n    updatefound() {\n      console.log('New content is downloading.');\n    },\n    updated() {\n      console.log('New content is available; please refresh.');\n    },\n    offline() {\n      console.log('No internet connection found. App is running in offline mode.');\n    },\n    error(error) {\n      console.error('Error during service worker registration:', error);\n    },\n  });\n}\n","import Vue from 'vue';\nimport App from './App.vue';\nimport './registerServiceWorker';\n\nVue.config.productionTip = false;\nVue.config.ignoredElements = [\n  'ion-app',\n  'ion-page',\n  'ion-header',\n  'ion-toolbar',\n  'ion-title',\n  'ion-content',\n  'ion-button',\n  'ion-icon',\n  'ion-menu-toggle',\n  'ion-item',\n  'ion-label',\n  'ion-checkbox',\n  'ion-toggle',\n  'ion-item-divider',\n  'ion-item-group',\n  'ion-buttons',\n  'ion-select',\n  'ion-select-option',\n  'ion-input',\n  'ion-list-header',\n  'ion-list',\n  'ion-split-pane',\n  'ion-menu',\n];\n\nnew Vue({\n  render: (h) => h(App),\n}).$mount('#app');\n"],"sourceRoot":""}