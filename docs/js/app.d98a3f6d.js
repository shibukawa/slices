(function(n){function e(e){for(var i,o,l=e[0],a=e[1],c=e[2],f=0,m=[];f<l.length;f++)o=l[f],t[o]&&m.push(t[o][0]),t[o]=0;for(i in a)Object.prototype.hasOwnProperty.call(a,i)&&(n[i]=a[i]);u&&u(e);while(m.length)m.shift()();return s.push.apply(s,c||[]),r()}function r(){for(var n,e=0;e<s.length;e++){for(var r=s[e],i=!0,l=1;l<r.length;l++){var a=r[l];0!==t[a]&&(i=!1)}i&&(s.splice(e--,1),n=o(o.s=r[0]))}return n}var i={},t={app:0},s=[];function o(e){if(i[e])return i[e].exports;var r=i[e]={i:e,l:!1,exports:{}};return n[e].call(r.exports,r,r.exports,o),r.l=!0,r.exports}o.m=n,o.c=i,o.d=function(n,e,r){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},o.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"===typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(o.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)o.d(r,i,function(e){return n[e]}.bind(null,i));return r},o.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/slices/";var l=window["webpackJsonp"]=window["webpackJsonp"]||[],a=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var u=a;s.push([0,"chunk-vendors"]),r()})({0:function(n,e,r){n.exports=r("cd49")},"5c0b":function(n,e,r){"use strict";var i=r("5e27"),t=r.n(i);t.a},"5e27":function(n,e,r){},cd49:function(n,e,r){"use strict";r.r(e);var i=r("2b0e"),t=function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("div",{attrs:{id:"app"}},[r("ion-app",[r("ion-split-pane",{attrs:{when:"sm"}},[r("ion-menu",[r("ion-content",{attrs:{padding:""}},[r("ConfigPanel",{model:{value:n.config,callback:function(e){n.config=e},expression:"config"}})],1)],1),r("ion-page",{staticClass:"ion-page",attrs:{main:""}},[r("ion-header",{attrs:{mode:"md"}},[r("ion-toolbar",{attrs:{mode:"md",color:"primary"}},[r("ion-buttons",{attrs:{slot:"start"},slot:"start"},[r("ion-menu-toggle",[r("ion-button",[r("ion-icon",{attrs:{slot:"icon-only",name:"menu"},slot:"icon-only"})],1)],1)],1),r("ion-title",[n._v("Go slice algorithms code generator")])],1)],1),r("ion-content",{attrs:{padding:""}},[r("pre",{staticClass:"line-numbers"},[n._v("            "),r("code",{staticClass:"language-go",attrs:{id:"goCode"}},[n._v(n._s(n.goCode()))]),n._v("\n          ")])])],1)],1)],1)],1)},s=[],o=r("9ab4"),l=r("60a3");function a(n,e,r){var i=n[0].toUpperCase()+n.slice(1),t=""+r.funcPrefix+i+r.funcSuffix;return e?t:t[0].toLowerCase()+t.slice(1)}function c(n){var e=n.packageName,r=n.sliceType,i=a("Sort",!0,n),t=a("BinarySearch",!0,n),s=a("IndexOf",!0,n),o=a("Contains",!0,n),l=a("Insert",!0,n),c=a("Remove",!0,n),u=a("IterateOver",!0,n),f=a("Merge",!0,n),m=a("LessThan",!0,n);return"\n    package "+e+'\n\n    import (\n        "sort"\n    )\n\n    // '+m+" is delegate type that sorting uses as a comparator\n    type "+m+" func(a, b "+r+") bool\n\n    // "+i+" sorts an array using the provided comparator\n    func "+i+"(a []"+r+", lt "+m+") (err error) {\n        sort.Slice(a, func(i, j int) bool {\n            return lt(a[i], a[j])\n        })\n        return nil\n    }\n\n    // "+t+" returns first index i that satisfies slices[i] <= item.\n    func "+t+"(sorted []"+r+", item "+r+", lt "+m+") int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if lt(sorted[h], item) {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // "+s+" returns index of item. If item is not in a sorted slice, it returns -1.\n    func "+s+"(sorted []"+r+", item "+r+", lt "+m+") int {\n        i := "+t+"(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return i\n        }\n        return -1\n    }\n\n    // "+o+" returns true if item is in a sorted slice. Otherwise false.\n    func "+o+"(sorted []"+r+", item "+r+", lt "+m+") bool {\n        i := "+t+"(sorted, item, lt)\n        return !lt(sorted[i], item) && !lt(item, sorted[i])\n    }\n\n    // "+l+" inserts item in correct position and returns a sorted slice.\n    func "+l+"(sorted []"+r+", item "+r+", lt "+m+") []"+r+" {\n        i := "+t+"(sorted, item, lt)\n        if i == len(sorted) - 1 && lt(sorted[i], item) {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]"+r+"{item}, sorted[i:]...)...)\n    }\n\n    // "+c+" removes item in a sorted slice.\n    func "+c+"(sorted []"+r+", item "+r+", lt "+m+") []"+r+" {\n        i := "+t+"(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // "+u+" iterates over input sorted slices and calls callback with each items in ascendant order.\n    func "+u+"(lt "+m+", callback func(item "+r+", srcIndex int), sorted ...[]"+r+") {\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // "+f+" merges sorted slices and returns new slices.\n    func "+f+"(lt "+m+", sorted ...[]"+r+") []"+r+" {\n        length := 0\n        for _, src := range sorted {\n            length += len(src)\n        }\n        result := make([]"+r+", length)\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n    "}function u(n){var e=n.packageName,r=n.sliceType,i=a("Sort",!0,n),t=a("BinarySearch",!0,n),s=a("IndexOf",!0,n),o=a("Contains",!0,n),l=a("Insert",!0,n),c=a("Remove",!0,n),u=a("IterateOver",!0,n),f=a("Merge",!0,n);a("LessThan",!0,n);return"\n    package "+e+'\n\n    import (\n        "sort"\n    )\n\n    // '+i+" sorts an array using the provided comparator\n    func "+i+"(a []"+r+") (err error) {\n        sort.Slice(a, func(i, j int) bool {\n            return a[i] < a[j]\n        })\n        return nil\n    }\n\n    // "+t+" returns first index i that satisfies slices[i] <= item.\n    func "+t+"(sorted []"+r+", item "+r+") int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if sorted[h] < item {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // "+s+" returns index of item. If item is not in a sorted slice, it returns -1.\n    func "+s+"(sorted []"+r+", item "+r+") int {\n        i := "+t+"(sorted, item, lt)\n        if sorted[i] == item {\n            return i\n        }\n        return -1\n    }\n\n    // "+o+" returns true if item is in a sorted slice. Otherwise false.\n    func "+o+"(sorted []"+r+", item "+r+") bool {\n        i := "+t+"(sorted, item, lt)\n        return sorted[i] == item\n    }\n\n    // "+l+" inserts item in correct position and returns a sorted slice.\n    func "+l+"(sorted []"+r+", item "+r+") []"+r+" {\n        i := "+t+"(sorted, item, lt)\n        if i == len(sorted) - 1 && sorted[i] < item {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]"+r+"{item}, sorted[i:]...)...)\n    }\n\n    // "+c+" removes item in a sorted slice.\n    func "+c+"(sorted []"+r+", item "+r+") []"+r+" {\n        i := "+t+"(sorted, item, lt)\n        if sorted[i] == item {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // "+u+" iterates over input sorted slices and calls callback with each items in ascendant order.\n    func "+u+"(callback func(item "+r+", srcIndex int), sorted ...[]"+r+") {\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // "+f+" merges sorted slices and returns new slices.\n    func "+f+"(sorted ...[]"+r+") []"+r+" {\n        length := 0\n        for _, src := range sorted {\n            length += len(src)\n        }\n        result := make([]"+r+", length)\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n    "}function f(n){var e=n.packageName,r=n.sliceType,i=a("Sort",!0,n),t=a("BinarySearch",!0,n),s=a("IndexOf",!0,n),o=a("Contains",!0,n),l=a("Insert",!0,n),c=a("Remove",!0,n),u=a("IterateOver",!0,n),f=a("Merge",!0,n),m=a("LessThan",!0,n),d=a("newTimSort",!1,n),p=a("reverseRange",!1,n),h=a("minRunLength",!1,n),S=a("countRunAndMakeAscending",!1,n),g=a("binarySort",!1,n),b=a("timSortHandler",!1,n),x=a("gallopLeft",!1,n),y=a("gallopRight",!1,n);return"\n    package "+e+'\n\n    import (\n        "errors"\n        "fmt"\n    )\n\n    // '+m+" is delegate type that sorting uses as a comparator\n    type "+m+" func(a, b "+r+") bool\n\n    // "+t+" returns first index i that satisfies slices[i] <= item.\n    func "+t+"(sorted []"+r+", item "+r+", lt "+m+") int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if lt(sorted[h], item) {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // "+s+" returns index of item. If item is not in a sorted slice, it returns -1.\n    func "+s+"(sorted []"+r+", item "+r+", lt "+m+") int {\n        i := "+t+"(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return i\n        }\n        return -1\n    }\n\n    // "+o+" returns true if item is in a sorted slice. Otherwise false.\n    func "+o+"(sorted []"+r+", item "+r+", lt "+m+") bool {\n        i := "+t+"(sorted, item, lt)\n        return !lt(sorted[i], item) && !lt(item, sorted[i])\n    }\n\n    // "+l+" inserts item in correct position and returns a sorted slice.\n    func "+l+"(sorted []"+r+", item "+r+", lt "+m+") []"+r+" {\n        i := "+t+"(sorted, item, lt)\n        if i == len(sorted) - 1 && lt(sorted[i], item) {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]"+r+"{item}, sorted[i:]...)...)\n    }\n\n    // "+c+" removes item in a sorted slice.\n    func "+c+"(sorted []"+r+", item "+r+", lt "+m+") []"+r+" {\n        i := "+t+"(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // "+u+" iterates over input sorted slices and calls callback with each items in ascendant order.\n    func "+u+"(lt "+m+", callback func(item "+r+", srcIndex int), sorted ...[]"+r+") {\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // "+f+" merges sorted slices and returns new slices.\n    func "+f+"(lt "+m+", sorted ...[]"+r+") []"+r+" {\n        length := 0\n        for _, src := range sorted {\n            length += len(src)\n        }\n        result := make([]"+r+", length)\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n\n    // timsort code is based on https://github.com/psilva261/timsort\n    //\n    // Package timsort provides fast stable sort, uses external comparator.\n    //\n    // A stable, adaptive, iterative mergesort that requires far fewer than\n    // n lg(n) comparisons when running on partially sorted arrays, while\n    // offering performance comparable to a traditional mergesort when run\n    // on random arrays.  Like all proper mergesorts, this sort is stable and\n    // runs O(n log n) time (worst case).  In the worst case, this sort requires\n    // temporary storage space for n/2 object references; in the best case,\n    // it requires only a small constant amount of space.\n    //\n    // This implementation was derived from Java's TimSort object by Josh Bloch,\n    // which, in turn, was based on the original code by Tim Peters:\n    //\n    // http://svn.python.org/projects/python/trunk/Objects/listsort.txt\n    //\n    // Mike K.\n    // "+m+" is Delegate type that sorting uses as a comparator\n\n    // "+i+" sorts an array using the provided comparator\n    func "+i+"(a []"+r+", lt "+m+") (err error) {\n        const minMerge = 32\n        lo := 0\n        hi := len(a)\n        nRemaining := hi\n        if nRemaining < 2 {\n            return\n        }\n        if nRemaining < minMerge {\n            initRunLen, err := "+S+"(a, lo, hi, lt)\n            if err != nil {\n                return err\n            }\n            return "+g+"(a, lo, hi, lo+initRunLen, lt)\n        }\n        ts := "+d+"(a, lt)\n        minRun, err := "+h+"(nRemaining)\n        if err != nil {\n            return\n        }\n        for {\n            runLen, err := "+S+"(a, lo, hi, lt)\n            if err != nil {\n                return err\n            }\n            if runLen < minRun {\n                force := minRun\n                if nRemaining <= minRun {\n                    force = nRemaining\n                }\n                if err = "+g+'(a, lo, lo+force, lo+runLen, lt); err != nil {\n                    return err\n                }\n                runLen = force\n            }\n            ts.pushRun(lo, runLen)\n            if err = ts.mergeCollapse(); err != nil {\n                return err\n            }\n            lo += runLen\n            nRemaining -= runLen\n            if nRemaining == 0 {\n                break\n            }\n        }\n        if lo != hi {\n            return errors.New("lo must equal hi")\n        }\n        if err = ts.mergeForceCollapse(); err != nil {\n            return\n        }\n        if ts.stackSize != 1 {\n            return errors.New("ts.stackSize != 1")\n        }\n        return\n    }\n\n    type '+b+" struct {\n        a []"+r+"\n        lt "+m+"\n        minGallop int\n        tmp []"+r+" // Actual runtime type will be Object[], regardless of "+r+"\n        stackSize int // Number of pending runs on stack\n        runBase   []int\n        runLen    []int\n    }\n\n    func "+d+"(a []"+r+", lt "+m+") (h *"+b+") {\n        minGallop := 7\n        initialTmpStorageLength := 256\n        h = new("+b+")\n\n        h.a = a\n        h.lt = lt\n        h.minGallop = minGallop\n        h.stackSize = 0\n        len := len(a)\n\n        tmpSize := initialTmpStorageLength\n        if len < 2*tmpSize {\n            tmpSize = len / 2\n        }\n\n        h.tmp = make([]"+r+", tmpSize)\n        stackLen := 40\n        if len < 120 {\n            stackLen = 5\n        } else if len < 1542 {\n            stackLen = 10\n        } else if len < 119151 {\n            stackLen = 19\n        }\n\n        h.runBase = make([]int, stackLen)\n        h.runLen = make([]int, stackLen)\n\n        return h\n    }\n\n    func "+g+"(a []"+r+", lo, hi, start int, lt "+m+') (err error) {\n        if lo > start || start > hi {\n            return errors.New("lo <= start && start <= hi")\n        }\n\n        if start == lo {\n            start++\n        }\n\n        for ; start < hi; start++ {\n            pivot := a[start]\n            left := lo\n            right := start\n            if left > right {\n                return errors.New("left <= right")\n            }\n            for left < right {\n                mid := int(uint(left+right) >> 1)\n                if lt(pivot, a[mid]) {\n                    right = mid\n                } else {\n                    left = mid + 1\n                }\n            }\n            if left != right {\n                return errors.New("left == right")\n            }\n            n := start - left // The number of elements to move\n            if n <= 2 {\n                if n == 2 {\n                    a[left+2] = a[left+1]\n                }\n                if n > 0 {\n                    a[left+1] = a[left]\n                }\n            } else {\n                copy(a[left+1:], a[left:left+n])\n            }\n            a[left] = pivot\n        }\n        return\n    }\n\n    func '+S+"(a []"+r+", lo, hi int, lt "+m+') (int, error) {\n        if lo >= hi {\n            return 0, errors.New("lo < hi")\n        }\n        runHi := lo + 1\n        if runHi == hi {\n            return 1, nil\n        }\n        if lt(a[runHi], a[lo]) {\n            runHi++\n            for runHi < hi && lt(a[runHi], a[runHi-1]) {\n                runHi++\n            }\n            '+p+"(a, lo, runHi)\n        } else {\n            for runHi < hi && !lt(a[runHi], a[runHi-1]) {\n                runHi++\n            }\n        }\n        return runHi - lo, nil\n    }\n\n    func "+p+"(a []"+r+", lo, hi int) {\n        hi--\n        for lo < hi {\n            a[lo], a[hi] = a[hi], a[lo]\n            lo++\n            hi--\n        }\n    }\n\n    func "+h+'(n int) (int, error) {\n        const minMerge = 32\n        if n < 0 {\n            return 0, errors.New("n >= 0")\n        }\n        r := 0 // Becomes 1 if any 1 bits are shifted off\n        for n >= minMerge {\n            r |= (n & 1)\n            n >>= 1\n        }\n        return n + r, nil\n    }\n\n    func (h *'+b+") pushRun(runBase, runLen int) {\n        h.runBase[h.stackSize] = runBase\n        h.runLen[h.stackSize] = runLen\n        h.stackSize++\n    }\n\n    func (h *"+b+") mergeCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if (n > 0 && h.runLen[n-1] <= h.runLen[n]+h.runLen[n+1]) ||\n                (n > 1 && h.runLen[n-2] <= h.runLen[n-1]+h.runLen[n]) {\n                if h.runLen[n-1] < h.runLen[n+1] {\n                    n--\n                }\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else if h.runLen[n] <= h.runLen[n+1] {\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else {\n                break\n            }\n        }\n        return\n    }\n\n    func (h *"+b+") mergeForceCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if n > 0 && h.runLen[n-1] < h.runLen[n+1] {\n                n--\n            }\n            if err = h.mergeAt(n); err != nil {\n                return\n            }\n        }\n        return\n    }\n\n    func (h *"+b+') mergeAt(i int) (err error) {\n        if h.stackSize < 2 {\n            return errors.New("stackSize >= 2")\n        }\n        if i < 0 {\n            return errors.New(" i >= 0")\n        }\n        if i != h.stackSize-2 && i != h.stackSize-3 {\n            return errors.New("if i == stackSize - 2 || i == stackSize - 3")\n        }\n        base1 := h.runBase[i]\n        len1 := h.runLen[i]\n        base2 := h.runBase[i+1]\n        len2 := h.runLen[i+1]\n        if len1 <= 0 || len2 <= 0 {\n            return errors.New("len1 > 0 && len2 > 0")\n        }\n        if base1+len1 != base2 {\n            return errors.New("base1 + len1 == base2")\n        }\n        h.runLen[i] = len1 + len2\n        if i == h.stackSize-3 {\n            h.runBase[i+1] = h.runBase[i+2]\n            h.runLen[i+1] = h.runLen[i+2]\n        }\n        h.stackSize--\n        k, err := '+y+'(h.a[base2], h.a, base1, len1, 0, h.lt)\n        if err != nil {\n            return err\n        }\n        if k < 0 {\n            return errors.New(" k >= 0;")\n        }\n        base1 += k\n        len1 -= k\n        if len1 == 0 {\n            return\n        }\n        len2, err = '+x+'(h.a[base1+len1-1], h.a, base2, len2, len2-1, h.lt)\n        if err != nil {\n            return\n        }\n        if len2 < 0 {\n            return errors.New(" len2 >= 0;")\n        }\n        if len2 == 0 {\n            return\n        }\n        if len1 <= len2 {\n            err = h.mergeLo(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf("mergeLo: %v", err)\n            }\n        } else {\n            err = h.mergeHi(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf("mergeHi: %v", err)\n            }\n        }\n        return\n    }\n\n    func '+x+"(key "+r+", a []"+r+", base, len, hint int, c "+m+') (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(" len > 0 && hint >= 0 && hint < len;")\n        }\n        lastOfs := 0\n        ofs := 1\n\n        if c(a[base+hint], key) {\n            maxOfs := len - hint\n            for ofs < maxOfs && c(a[base+hint+ofs], key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        } else {\n            maxOfs := hint + 1\n            for ofs < maxOfs && !c(a[base+hint-ofs], key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(" -1 <= lastOfs && lastOfs < ofs && ofs <= len;")\n        }\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if c(a[base+m], key) {\n                lastOfs = m + 1\n            } else {\n                ofs = m\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(" lastOfs == ofs")\n        }\n        return ofs, nil\n    }\n\n    func '+y+"(key "+r+", a []"+r+", base, len, hint int, c "+m+') (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(" len > 0 && hint >= 0 && hint < len;")\n        }\n\n        ofs := 1\n        lastOfs := 0\n        if c(key, a[base+hint]) {\n            maxOfs := hint + 1\n            for ofs < maxOfs && c(key, a[base+hint-ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        } else {\n            maxOfs := len - hint\n            for ofs < maxOfs && !c(key, a[base+hint+ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New("-1 <= lastOfs && lastOfs < ofs && ofs <= len")\n        }\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if c(key, a[base+m]) {\n                ofs = m\n            } else {\n                lastOfs = m + 1\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(" lastOfs == ofs")\n        }\n        return ofs, nil\n    }\n\n    func (h *'+b+') mergeLo(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(" len1 > 0 && len2 > 0 && base1 + len1 == base2")\n        }\n        a := h.a\n        tmp := h.ensureCapacity(len1)\n        copy(tmp, a[base1:base1+len1])\n        cursor1 := 0\n        cursor2 := base2\n        dest := base1\n        a[dest] = a[cursor2]\n        dest++\n        cursor2++\n        len2--\n        if len2 == 0 {\n            copy(a[dest:dest+len1], tmp)\n            return\n        }\n        if len1 == 1 {\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1]\n            return\n        }\n        lt := h.lt\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0\n            count2 := 0\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(" len1 > 1 && len2 > 0")\n                }\n\n                if lt(a[cursor2], tmp[cursor1]) {\n                    a[dest] = a[cursor2]\n                    dest++\n                    cursor2++\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor1]\n                    dest++\n                    cursor1++\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New("len1 > 1 && len2 > 0")\n                }\n                count1, err = '+y+"(a[cursor2], tmp, cursor1, len1, 0, lt)\n                if err != nil {\n                    return\n                }\n                if count1 != 0 {\n                    copy(a[dest:dest+count1], tmp[cursor1:cursor1+count1])\n                    dest += count1\n                    cursor1 += count1\n                    len1 -= count1\n                    if len1 <= 1 {\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor2]\n                dest++\n                cursor2++\n                len2--\n                if len2 == 0 {\n                    break outer\n                }\n                count2, err = "+x+'(tmp[cursor1], a, cursor2, len2, 0, lt)\n                if err != nil {\n                    return\n                }\n                if count2 != 0 {\n                    copy(a[dest:dest+count2], a[cursor2:cursor2+count2])\n                    dest += count2\n                    cursor2 += count2\n                    len2 -= count2\n                    if len2 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor1]\n                dest++\n                cursor1++\n                len1--\n                if len1 == 1 {\n                    break outer\n                }\n                minGallop--\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2\n        }\n        if minGallop < 1 {\n            minGallop = 1\n        }\n        h.minGallop = minGallop\n        if len1 == 1 {\n\n            if len2 <= 0 {\n                return errors.New(" len2 > 0;")\n            }\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1]\n        } else if len1 == 0 {\n            return errors.New("comparison method violates its general contract")\n        } else {\n            if len2 != 0 {\n                return errors.New("len2 == 0;")\n            }\n            if len1 <= 1 {\n                return errors.New(" len1 > 1;")\n            }\n            copy(a[dest:dest+len1], tmp[cursor1:cursor1+len1])\n        }\n        return\n    }\n\n    func (h *'+b+') mergeHi(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New("len1 > 0 && len2 > 0 && base1 + len1 == base2;")\n        }\n        a := h.a\n        tmp := h.ensureCapacity(len2)\n        copy(tmp, a[base2:base2+len2])\n        cursor1 := base1 + len1 - 1\n        cursor2 := len2 - 1\n        dest := base2 + len2 - 1\n        a[dest] = a[cursor1]\n        dest--\n        cursor1--\n        len1--\n        if len1 == 0 {\n            dest -= len2 - 1\n            copy(a[dest:dest+len2], tmp)\n            return\n        }\n        if len2 == 1 {\n            dest -= len1 - 1\n            cursor1 -= len1 - 1\n            copy(a[dest:dest+len1], a[cursor1:cursor1+len1])\n            a[dest-1] = tmp[cursor2]\n            return\n        }\n        lt := h.lt\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(" len1 > 0 && len2 > 1;")\n                }\n                if lt(tmp[cursor2], a[cursor1]) {\n                    a[dest] = a[cursor1]\n                    dest--\n                    cursor1--\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor2]\n                    dest--\n                    cursor2--\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(" len1 > 0 && len2 > 1;")\n                }\n                if gr, err := '+y+"(tmp[cursor2], a, base1, len1, len1-1, lt); err == nil {\n                    count1 = len1 - gr\n                } else {\n                    return err\n                }\n                if count1 != 0 {\n                    dest -= count1\n                    cursor1 -= count1\n                    len1 -= count1\n                    copy(a[dest+1:dest+1+count1], a[cursor1+1:cursor1+1+count1])\n                    if len1 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor2]\n                dest--\n                cursor2--\n                len2--\n                if len2 == 1 {\n                    break outer\n                }\n\n                if gl, err := "+x+'(a[cursor1], tmp, 0, len2, len2-1, lt); err == nil {\n                    count2 = len2 - gl\n                } else {\n                    return err\n                }\n                if count2 != 0 {\n                    dest -= count2\n                    cursor2 -= count2\n                    len2 -= count2\n                    copy(a[dest+1:dest+1+count2], tmp[cursor2+1:cursor2+1+count2])\n                    if len2 <= 1 { // len2 == 1 || len2 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor1]\n                dest--\n                cursor1--\n                len1--\n                if len1 == 0 {\n                    break outer\n                }\n                minGallop--\n\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        } // End of "outer" loop\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n\n        h.minGallop = minGallop // Write back to field\n\n        if len2 == 1 {\n            if len1 <= 0 {\n                return errors.New(" len1 > 0;")\n            }\n            dest -= len1\n            cursor1 -= len1\n\n            copy(a[dest+1:dest+1+len1], a[cursor1+1:cursor1+1+len1])\n            a[dest] = tmp[cursor2] // Move first elt of run2 to front of merge\n        } else if len2 == 0 {\n            return errors.New("comparison method violates its general contract")\n        } else {\n            if len1 != 0 {\n                return errors.New("len1 == 0;")\n            }\n\n            if len2 <= 0 {\n                return errors.New(" len2 > 0;")\n            }\n\n            copy(a[dest-(len2-1):dest+1], tmp)\n        }\n        return\n    }\n\n    func (h *'+b+") ensureCapacity(minCapacity int) []"+r+" {\n        if len(h.tmp) < minCapacity {\n            // Compute smallest power of 2 > minCapacity\n            newSize := minCapacity\n            newSize |= newSize >> 1\n            newSize |= newSize >> 2\n            newSize |= newSize >> 4\n            newSize |= newSize >> 8\n            newSize |= newSize >> 16\n            newSize++\n\n            if newSize < 0 { // Not bloody likely!\n                newSize = minCapacity\n            } else {\n                ns := len(h.a) / 2\n                if ns < newSize {\n                    newSize = ns\n                }\n            }\n\n            h.tmp = make([]"+r+", newSize)\n        }\n\n        return h.tmp\n    }\n    "}function m(n){var e=n.packageName,r=n.sliceType,i=a("Sort",!0,n),t=a("BinarySearch",!0,n),s=a("IndexOf",!0,n),o=a("Contains",!0,n),l=a("Insert",!0,n),c=a("Remove",!0,n),u=a("IterateOver",!0,n),f=a("Merge",!0,n),m=a("countRunAndMakeAscending",!1,n),d=a("reverseRange",!1,n),p=a("minRunLength",!1,n),h=a("binarySort",!1,n),S=a("timSortHandler",!1,n),g=a("gallopLeft",!1,n),b=a("gallopRight",!1,n);return"\n    package "+e+'\n\n    import (\n        "errors"\n        "fmt"\n    )\n\n    // '+t+" returns first index i that satisfies slices[i] <= item.\n    func "+t+"(sorted []"+r+", item "+r+") int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if sorted[h] < item {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // "+s+" returns index of item. If item is not in a sorted slice, it returns -1.\n    func "+s+"(sorted []"+r+", item "+r+") int {\n        i := "+t+"(sorted, item)\n        if sorted[i] == item {\n            return i\n        }\n        return -1\n    }\n\n    // "+o+" returns true if item is in a sorted slice. Otherwise false.\n    func "+o+"(sorted []"+r+", item "+r+") bool {\n        i := "+t+"(sorted, item)\n        return sorted[i] == item\n    }\n\n    // "+l+" inserts item in correct position and returns a sorted slice.\n    func "+l+"(sorted []"+r+", item "+r+") []"+r+" {\n        i := "+t+"(sorted, item)\n        if i == len(sorted) - 1 && sorted[i] < item {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]"+r+"{item}, sorted[i:]...)...)\n    }\n\n    // "+c+" removes item in a sorted slice.\n    func "+c+"(sorted []"+r+", item "+r+") []"+r+" {\n        i := "+t+"(sorted, item)\n        if sorted[i] == item {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // "+u+" iterates over input sorted slices and calls callback with each items in ascendant order.\n    func "+u+"(callback func(item "+r+", srcIndex int), sorted ...[]"+r+") {\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // "+f+" merges sorted slices and returns new slices.\n    func "+f+"(sorted ...[]"+r+") []"+r+" {\n        length := 0\n        for _, src := range sorted {\n            length += len(src)\n        }\n        result := make([]"+r+", length)\n        sourceSlices := sorted\n        sourceSliceCount := len(sorted)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n\n    // timsort code is based on https://github.com/psilva261/timsort\n    //\n    // Package timsort provides fast stable sort, uses external comparator.\n    //\n    // A stable, adaptive, iterative mergesort that requires far fewer than\n    // n lg(n) comparisons when running on partially sorted arrays, while\n    // offering performance comparable to a traditional mergesort when run\n    // on random arrays.  Like all proper mergesorts, this sort is stable and\n    // runs O(n log n) time (worst case).  In the worst case, this sort requires\n    // temporary storage space for n/2 object references; in the best case,\n    // it requires only a small constant amount of space.\n    //\n    // This implementation was derived from Java's TimSort object by Josh Bloch,\n    // which, in turn, was based on the original code by Tim Peters:\n    //\n    // http://svn.python.org/projects/python/trunk/Objects/listsort.txt\n    //\n    // Mike K.\n\n    // "+i+" sorts an array using the provided comparator\n    func "+i+"(a []"+r+") (err error) {\n        minMerge := 32\n        lo := 0\n        hi := len(a)\n        nRemaining := hi\n\n        if nRemaining < 2 {\n            return // Arrays of size 0 and 1 are always sorted\n        }\n\n        if nRemaining < minMerge {\n            initRunLen, err := "+m+"(a, lo, hi)\n            if err != nil {\n                return err\n            }\n            return "+h+"(a, lo, hi, lo+initRunLen)\n        }\n        ts := "+a("newTimSort",!1,n)+"(a)\n        minRun, err := "+p+"(nRemaining)\n        if err != nil {\n            return\n        }\n        for {\n            // Identify next run\n            runLen, err := "+m+"(a, lo, hi)\n            if err != nil {\n                return err\n            }\n            if runLen < minRun {\n                force := minRun\n                if nRemaining <= minRun {\n                    force = nRemaining\n                }\n                if err = "+h+'(a, lo, lo+force, lo+runLen); err != nil {\n                    return err\n                }\n                runLen = force\n            }\n            ts.pushRun(lo, runLen)\n            if err = ts.mergeCollapse(); err != nil {\n                return err\n            }\n            lo += runLen\n            nRemaining -= runLen\n            if nRemaining == 0 {\n                break\n            }\n        }\n        if lo != hi {\n            return errors.New("lo must equal hi")\n        }\n        if err = ts.mergeForceCollapse(); err != nil {\n            return\n        }\n        if ts.stackSize != 1 {\n            return errors.New("ts.stackSize != 1")\n        }\n        return\n    }\n\n    type '+S+" struct {\n        a []"+r+"\n        minGallop int\n        tmp []"+r+"\n        stackSize int\n        runBase   []int\n        runLen    []int\n    }\n\n    func "+a("newTimSort",!1,n)+"(a []"+r+") (h *"+S+") {\n        minGallop := 7\n        initialTmpStorageLength := 256\n        h = new("+S+")\n\n        h.a = a\n        h.minGallop = minGallop\n        h.stackSize = 0\n        len := len(a)\n        tmpSize := initialTmpStorageLength\n        if len < 2*tmpSize {\n            tmpSize = len / 2\n        }\n        h.tmp = make([]"+r+", tmpSize)\n        stackLen := 40\n        if len < 120 {\n            stackLen = 5\n        } else if len < 1542 {\n            stackLen = 10\n        } else if len < 119151 {\n            stackLen = 19\n        }\n        h.runBase = make([]int, stackLen)\n        h.runLen = make([]int, stackLen)\n        return h\n    }\n\n    func "+h+"(a []"+r+', lo, hi, start int) (err error) {\n        if lo > start || start > hi {\n            return errors.New("lo <= start && start <= hi")\n        }\n        if start == lo {\n            start++\n        }\n        for ; start < hi; start++ {\n            pivot := a[start]\n            left := lo\n            right := start\n            if left > right {\n                return errors.New("left <= right")\n            }\n            for left < right {\n                mid := int(uint(left+right) >> 1)\n                if pivot < a[mid] {\n                    right = mid\n                } else {\n                    left = mid + 1\n                }\n            }\n            if left != right {\n                return errors.New("left == right")\n            }\n            n := start - left // The number of elements to move\n            // just an optimization for copy in default case\n            if n <= 2 {\n                if n == 2 {\n                    a[left+2] = a[left+1]\n                }\n                if n > 0 {\n                    a[left+1] = a[left]\n                }\n            } else {\n                copy(a[left+1:], a[left:left+n])\n            }\n            a[left] = pivot\n        }\n        return\n    }\n\n    func '+m+"(a []"+r+', lo, hi int) (int, error) {\n        if lo >= hi {\n            return 0, errors.New("lo < hi")\n        }\n        runHi := lo + 1\n        if runHi == hi {\n            return 1, nil\n        }\n        if a[runHi] < a[lo] { // Descending\n            runHi++\n            for runHi < hi && a[runHi] < a[runHi-1] {\n                runHi++\n            }\n            '+d+"(a, lo, runHi)\n        } else { // Ascending\n            for runHi < hi && !(a[runHi] < a[runHi-1]) {\n                runHi++\n            }\n        }\n        return runHi - lo, nil\n    }\n\n    func "+d+"(a []"+r+", lo, hi int) {\n        hi--\n        for lo < hi {\n            a[lo], a[hi] = a[hi], a[lo]\n            lo++\n            hi--\n        }\n    }\n\n    func "+p+'(n int) (int, error) {\n        minMerge := 32\n        if n < 0 {\n            return 0, errors.New("n >= 0")\n        }\n        r := 0 // Becomes 1 if any 1 bits are shifted off\n        for n >= minMerge {\n            r |= (n & 1)\n            n >>= 1\n        }\n        return n + r, nil\n    }\n\n    func (h *'+S+") pushRun(runBase, runLen int) {\n        h.runBase[h.stackSize] = runBase\n        h.runLen[h.stackSize] = runLen\n        h.stackSize++\n    }\n\n    func (h *"+S+") mergeCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if (n > 0 && h.runLen[n-1] <= h.runLen[n]+h.runLen[n+1]) ||\n                (n > 1 && h.runLen[n-2] <= h.runLen[n-1]+h.runLen[n]) {\n                if h.runLen[n-1] < h.runLen[n+1] {\n                    n--\n                }\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else if h.runLen[n] <= h.runLen[n+1] {\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else {\n                break // Invariant is established\n            }\n        }\n        return\n    }\n\n    func (h *"+S+") mergeForceCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if n > 0 && h.runLen[n-1] < h.runLen[n+1] {\n                n--\n            }\n            if err = h.mergeAt(n); err != nil {\n                return\n            }\n        }\n        return\n    }\n\n    func (h *"+S+') mergeAt(i int) (err error) {\n        if h.stackSize < 2 {\n            return errors.New("stackSize >= 2")\n        }\n\n        if i < 0 {\n            return errors.New(" i >= 0")\n        }\n\n        if i != h.stackSize-2 && i != h.stackSize-3 {\n            return errors.New("if i == stackSize - 2 || i == stackSize - 3")\n        }\n\n        base1 := h.runBase[i]\n        len1 := h.runLen[i]\n        base2 := h.runBase[i+1]\n        len2 := h.runLen[i+1]\n\n        if len1 <= 0 || len2 <= 0 {\n            return errors.New("len1 > 0 && len2 > 0")\n        }\n\n        if base1+len1 != base2 {\n            return errors.New("base1 + len1 == base2")\n        }\n\n        h.runLen[i] = len1 + len2\n        if i == h.stackSize-3 {\n            h.runBase[i+1] = h.runBase[i+2]\n            h.runLen[i+1] = h.runLen[i+2]\n        }\n        h.stackSize--\n\n        k, err := '+b+'(h.a[base2], h.a, base1, len1, 0)\n        if err != nil {\n            return err\n        }\n        if k < 0 {\n            return errors.New(" k >= 0;")\n        }\n        base1 += k\n        len1 -= k\n        if len1 == 0 {\n            return\n        }\n\n        len2, err = '+g+'(h.a[base1+len1-1], h.a, base2, len2, len2-1)\n        if err != nil {\n            return\n        }\n        if len2 < 0 {\n            return errors.New(" len2 >= 0;")\n        }\n        if len2 == 0 {\n            return\n        }\n\n        if len1 <= len2 {\n            err = h.mergeLo(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf("mergeLo: %v", err)\n            }\n        } else {\n            err = h.mergeHi(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf("mergeHi: %v", err)\n            }\n        }\n        return\n    }\n\n    func '+g+"(key "+r+", a []"+r+', base, len, hint int) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(" len > 0 && hint >= 0 && hint < len;")\n        }\n        lastOfs := 0\n        ofs := 1\n\n        if a[base+hint] < key {\n            // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]\n            maxOfs := len - hint\n            for ofs < maxOfs && a[base+hint+ofs] < key {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        } else { // key <= a[base + hint]\n            // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]\n            maxOfs := hint + 1\n            for ofs < maxOfs && !(a[base+hint-ofs] < key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        }\n\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(" -1 <= lastOfs && lastOfs < ofs && ofs <= len;")\n        }\n\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n            if a[base+m] < key {\n                lastOfs = m + 1 // a[base + m] < key\n            } else {\n                ofs = m // key <= a[base + m]\n            }\n        }\n\n        if lastOfs != ofs {\n            return 0, errors.New(" lastOfs == ofs") // so a[base + ofs - 1] < key <= a[base + ofs]\n        }\n        return ofs, nil\n    }\n\n    func '+b+"(key "+r+", a []"+r+', base, len, hint int) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(" len > 0 && hint >= 0 && hint < len;")\n        }\n        ofs := 1\n        lastOfs := 0\n        if key < a[base+hint] {\n            // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]\n            maxOfs := hint + 1\n            for ofs < maxOfs && key < a[base+hint-ofs] {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        } else { // a[b + hint] <= key\n            // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]\n            maxOfs := len - hint\n            for ofs < maxOfs && !(key < a[base+hint+ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n\n            lastOfs += hint\n            ofs += hint\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New("-1 <= lastOfs && lastOfs < ofs && ofs <= len")\n        }\n\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if key < a[base+m] {\n                ofs = m // key < a[b + m]\n            } else {\n                lastOfs = m + 1 // a[b + m] <= key\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(" lastOfs == ofs") // so a[b + ofs - 1] <= key < a[b + ofs]\n        }\n        return ofs, nil\n    }\n\n    func (h *'+S+') mergeLo(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(" len1 > 0 && len2 > 0 && base1 + len1 == base2")\n        }\n\n        a := h.a // For performance\n        tmp := h.ensureCapacity(len1)\n\n        copy(tmp, a[base1:base1+len1])\n\n        cursor1 := 0     // Indexes into tmp array\n        cursor2 := base2 // Indexes int a\n        dest := base1    // Indexes int a\n\n        a[dest] = a[cursor2]\n        dest++\n        cursor2++\n        len2--\n        if len2 == 0 {\n            copy(a[dest:dest+len1], tmp)\n            return\n        }\n        if len1 == 1 {\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1] // Last elt of run 1 to end of merge\n            return\n        }\n\n        minGallop := h.minGallop\n\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(" len1 > 1 && len2 > 0")\n                }\n\n                if a[cursor2] < tmp[cursor1] {\n                    a[dest] = a[cursor2]\n                    dest++\n                    cursor2++\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor1]\n                    dest++\n                    cursor1++\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New("len1 > 1 && len2 > 0")\n                }\n                count1, err = '+b+"(a[cursor2], tmp, cursor1, len1, 0)\n                if err != nil {\n                    return\n                }\n                if count1 != 0 {\n                    copy(a[dest:dest+count1], tmp[cursor1:cursor1+count1])\n                    dest += count1\n                    cursor1 += count1\n                    len1 -= count1\n                    if len1 <= 1 { // len1 == 1 || len1 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor2]\n                dest++\n                cursor2++\n                len2--\n                if len2 == 0 {\n                    break outer\n                }\n\n                count2, err = "+g+'(tmp[cursor1], a, cursor2, len2, 0)\n                if err != nil {\n                    return\n                }\n                if count2 != 0 {\n                    copy(a[dest:dest+count2], a[cursor2:cursor2+count2])\n                    dest += count2\n                    cursor2 += count2\n                    len2 -= count2\n                    if len2 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor1]\n                dest++\n                cursor1++\n                len1--\n                if len1 == 1 {\n                    break outer\n                }\n                minGallop--\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        }\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n        h.minGallop = minGallop // Write back to field\n\n        if len1 == 1 {\n            if len2 <= 0 {\n                return errors.New(" len2 > 0;")\n            }\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1] //  Last elt of run 1 to end of merge\n        } else if len1 == 0 {\n            return errors.New("comparison method violates its general contract")\n        } else {\n            if len2 != 0 {\n                return errors.New("len2 == 0;")\n            }\n            if len1 <= 1 {\n                return errors.New(" len1 > 1;")\n            }\n\n            copy(a[dest:dest+len1], tmp[cursor1:cursor1+len1])\n        }\n        return\n    }\n\n    func (h *'+S+') mergeHi(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New("len1 > 0 && len2 > 0 && base1 + len1 == base2;")\n        }\n\n        a := h.a // For performance\n        tmp := h.ensureCapacity(len2)\n\n        copy(tmp, a[base2:base2+len2])\n\n        cursor1 := base1 + len1 - 1 // Indexes into a\n        cursor2 := len2 - 1         // Indexes into tmp array\n        dest := base2 + len2 - 1    // Indexes into a\n\n        a[dest] = a[cursor1]\n        dest--\n        cursor1--\n        len1--\n        if len1 == 0 {\n            dest -= len2 - 1\n            copy(a[dest:dest+len2], tmp)\n            return\n        }\n        if len2 == 1 {\n            dest -= len1 - 1\n            cursor1 -= len1 - 1\n            copy(a[dest:dest+len1], a[cursor1:cursor1+len1])\n            a[dest-1] = tmp[cursor2]\n            return\n        }\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(" len1 > 0 && len2 > 1;")\n                }\n                if tmp[cursor2] < a[cursor1] {\n                    a[dest] = a[cursor1]\n                    dest--\n                    cursor1--\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor2]\n                    dest--\n                    cursor2--\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(" len1 > 0 && len2 > 1;")\n                }\n                if gr, err := '+b+"(tmp[cursor2], a, base1, len1, len1-1); err == nil {\n                    count1 = len1 - gr\n                } else {\n                    return err\n                }\n                if count1 != 0 {\n                    dest -= count1\n                    cursor1 -= count1\n                    len1 -= count1\n                    copy(a[dest+1:dest+1+count1], a[cursor1+1:cursor1+1+count1])\n                    if len1 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor2]\n                dest--\n                cursor2--\n                len2--\n                if len2 == 1 {\n                    break outer\n                }\n\n                if gl, err := "+g+'(a[cursor1], tmp, 0, len2, len2-1); err == nil {\n                    count2 = len2 - gl\n                } else {\n                    return err\n                }\n                if count2 != 0 {\n                    dest -= count2\n                    cursor2 -= count2\n                    len2 -= count2\n                    copy(a[dest+1:dest+1+count2], tmp[cursor2+1:cursor2+1+count2])\n                    if len2 <= 1 { // len2 == 1 || len2 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor1]\n                dest--\n                cursor1--\n                len1--\n                if len1 == 0 {\n                    break outer\n                }\n                minGallop--\n\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        } // End of "outer" loop\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n\n        h.minGallop = minGallop // Write back to field\n\n        if len2 == 1 {\n            if len1 <= 0 {\n                return errors.New(" len1 > 0;")\n            }\n            dest -= len1\n            cursor1 -= len1\n\n            copy(a[dest+1:dest+1+len1], a[cursor1+1:cursor1+1+len1])\n            a[dest] = tmp[cursor2] // Move first elt of run2 to front of merge\n        } else if len2 == 0 {\n            return errors.New("comparison method violates its general contract")\n        } else {\n            if len1 != 0 {\n                return errors.New("len1 == 0;")\n            }\n\n            if len2 <= 0 {\n                return errors.New(" len2 > 0;")\n            }\n\n            copy(a[dest-(len2-1):dest+1], tmp)\n        }\n        return\n    }\n\n    func (h *'+S+") ensureCapacity(minCapacity int) []"+r+" {\n        if len(h.tmp) < minCapacity {\n            // Compute smallest power of 2 > minCapacity\n            newSize := minCapacity\n            newSize |= newSize >> 1\n            newSize |= newSize >> 2\n            newSize |= newSize >> 4\n            newSize |= newSize >> 8\n            newSize |= newSize >> 16\n            newSize++\n\n            if newSize < 0 { // Not bloody likely!\n                newSize = minCapacity\n            } else {\n                ns := len(h.a) / 2\n                if ns < newSize {\n                    newSize = ns\n                }\n            }\n\n            h.tmp = make([]"+r+", newSize)\n        }\n        return h.tmp\n    }\n    "}function d(n){var e;return e=n.acceptLessThan?n.useTimSort?f(n):c(n):n.useTimSort?m(n):u(n),p(e)}function p(n){var e=n.split("\n"),r=(e[0],e.slice(1)),i=r.map(function(n){n=n.slice(4);var e=n.match(/^( +)/);if(e){var r=Math.floor(e[1].length/4),i=new Array(r+1).join("    "),t=new Array(r+1).join("\t");n=n.replace(i,t)}return n});return i.join("\n")}var h=function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ion-list",[r("ion-item-group",[r("ion-list-header",[r("ion-label",[n._v("Package/File information")])],1),r("ion-item",[r("ion-label",{attrs:{position:"stacked"}},[n._v("Package Name")]),r("ion-input",{attrs:{value:n.getPackageName},on:{ionInput:function(e){return n.onChangePackageName(e)}}})],1),r("ion-item",[r("ion-label",{attrs:{position:"stacked"}},[n._v("Function Prefix")]),r("ion-input",{attrs:{value:n.getFunctionPrefix},on:{ionInput:function(e){return n.onChangeFunctionPrefix(e)}}})],1),r("ion-item",[r("ion-label",{attrs:{position:"stacked"}},[n._v("Function Suffix")]),r("ion-input",{attrs:{value:n.getFunctionSuffix},on:{ionInput:function(e){return n.onChangeFunctionSuffix(e)}}})],1)],1),r("ion-item-group",[r("ion-list-header",[r("ion-label",[n._v("Generator Option")])],1),r("ion-item",[r("ion-label",[n._v("Use Primitive Type")]),r("ion-toggle",{attrs:{slot:"end",color:"primary",checked:n.doesUsePrimitiveType},on:{ionChange:function(e){return n.onChangeType(e)}},slot:"end"})],1),r("ion-item",[r("ion-label",{attrs:{position:"stacked",color:n.doesUsePrimitiveType?"medium":void 0}},[n._v("Slice Types")]),r("ion-input",{attrs:{value:n.getSliceType,disabled:n.doesUsePrimitiveType},on:{ionChange:function(e){return n.onChangeSliceType(e)}}})],1),r("ion-item",[r("ion-label",{attrs:{position:"stacked",color:n.doesUsePrimitiveType?void 0:"medium"}},[n._v("Primitive Type")]),r("ion-select",{attrs:{value:n.getPrimitiveSliceType,okText:"Okay",cancelText:"Dismiss",disabled:!n.doesUsePrimitiveType},on:{ionChange:function(e){return n.onChangePrimitiveSliceType(e)}}},[r("ion-select-option",{attrs:{value:"int"}},[n._v("int")]),r("ion-select-option",{attrs:{value:"uint"}},[n._v("uint")]),r("ion-select-option",{attrs:{value:"byte"}},[n._v("byte")]),r("ion-select-option",{attrs:{value:"rune"}},[n._v("rune")]),r("ion-select-option",{attrs:{value:"int8"}},[n._v("int8")]),r("ion-select-option",{attrs:{value:"uint8"}},[n._v("uint8")]),r("ion-select-option",{attrs:{value:"int16"}},[n._v("int16")]),r("ion-select-option",{attrs:{value:"uint16"}},[n._v("uint16")]),r("ion-select-option",{attrs:{value:"int32"}},[n._v("int32")]),r("ion-select-option",{attrs:{value:"uint32"}},[n._v("uint32")]),r("ion-select-option",{attrs:{value:"int64"}},[n._v("int64")]),r("ion-select-option",{attrs:{value:"uint64"}},[n._v("uint64")]),r("ion-select-option",{attrs:{value:"float32"}},[n._v("float32")]),r("ion-select-option",{attrs:{value:"float64"}},[n._v("float64")])],1)],1),r("ion-item",[r("ion-label",[n._v("Accept LessThan function")]),r("ion-toggle",{attrs:{slot:"end",checked:n.doesAcceptLessThan,color:"primary"},on:{ionChange:function(e){return n.onChangeAcceptLessThan(e)}},slot:"end"})],1),r("ion-item",[r("ion-label",[n._v("Use TimSort")]),r("ion-toggle",{attrs:{slot:"end",color:"primary",checked:n.doesUseTimSort},on:{ionChange:function(e){return n.onChangeUseTimSort(e)}},slot:"end"})],1)],1)],1)},S=[],g=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.pakcageName=e.value.packageName,e.functionPrefix=e.value.funcPrefix,e.functionSuffix=e.value.funcSuffix,e.sliceType=e.value.sliceType,e.primitiveSliceType="int",e.usePrimitiveType=!1,e.acceptLessThan=e.value.acceptLessThan,e.useTimSort=e.value.useTimSort,e}return o["b"](e,n),Object.defineProperty(e.prototype,"getPackageName",{get:function(){return this.pakcageName},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"getFunctionPrefix",{get:function(){return this.functionPrefix},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"getFunctionSuffix",{get:function(){return this.functionSuffix},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"getSliceType",{get:function(){return this.sliceType},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"doesUsePrimitiveType",{get:function(){return this.usePrimitiveType},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"getPrimitiveSliceType",{get:function(){return this.primitiveSliceType},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"doesAcceptLessThan",{get:function(){return this.acceptLessThan},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"doesUseTimSort",{get:function(){return this.useTimSort},enumerable:!0,configurable:!0}),e.prototype.onChangePackageName=function(n){this.pakcageName=n.target.value,this.emitConfig()},e.prototype.onChangeFunctionPrefix=function(n){this.functionPrefix=n.target.value,this.emitConfig()},e.prototype.onChangeFunctionSuffix=function(n){this.functionSuffix=n.target.value,this.emitConfig()},e.prototype.onChangeType=function(n){this.usePrimitiveType=n.target.checked,this.emitConfig()},e.prototype.onChangeSliceType=function(n){this.sliceType=n.target.value,this.emitConfig()},e.prototype.onChangePrimitiveSliceType=function(n){this.primitiveSliceType=n.target.value,this.emitConfig()},e.prototype.onChangeAcceptLessThan=function(n){this.acceptLessThan=n.target.checked,this.emitConfig()},e.prototype.onChangeUseTimSort=function(n){this.useTimSort=n.target.checked,this.emitConfig()},e.prototype.input=function(n){},e.prototype.emitConfig=function(){var n=this.usePrimitiveType?this.primitiveSliceType:this.sliceType,e={packageName:this.pakcageName,funcPrefix:this.functionPrefix,funcSuffix:this.functionSuffix,sliceType:n,acceptLessThan:this.acceptLessThan,useTimSort:this.useTimSort};this.input(e)},o["a"]([Object(l["c"])()],e.prototype,"value",void 0),o["a"]([Object(l["b"])()],e.prototype,"input",null),e=o["a"]([l["a"]],e),e}(l["d"]),b=g,x=b,y=r("2877"),k=Object(y["a"])(x,h,S,!1,null,null,null),v=k.exports,w=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.config={packageName:"main",funcPrefix:"MyStruct",funcSuffix:"",sliceType:"*MyStruct",acceptLessThan:!0,useTimSort:!1},e}return o["b"](e,n),e.prototype.goCode=function(){return d(this.config)},e.prototype.updated=function(){var n=document.getElementById("goCode");n.innerHTML=this.escapeHtml(this.goCode());var e=window;e.Prism.highlightAll()},e.prototype.escapeHtml=function(n){return n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")},e=o["a"]([Object(l["a"])({components:{ConfigPanel:v}})],e),e}(l["d"]),O=w,L=O,C=(r("5c0b"),Object(y["a"])(L,t,s,!1,null,null,null)),I=C.exports,N=r("9483");Object(N["a"])("/slices/service-worker.js",{ready:function(){console.log("App is being served from cache by a service worker.\nFor more details, visit https://goo.gl/AFskqB")},registered:function(){console.log("Service worker has been registered.")},cached:function(){console.log("Content has been cached for offline use.")},updatefound:function(){console.log("New content is downloading.")},updated:function(){console.log("New content is available; please refresh.")},offline:function(){console.log("No internet connection found. App is running in offline mode.")},error:function(n){console.error("Error during service worker registration:",n)}}),i["a"].config.productionTip=!1,i["a"].config.ignoredElements=["ion-app","ion-page","ion-header","ion-toolbar","ion-title","ion-content","ion-button","ion-icon","ion-menu-toggle","ion-item","ion-label","ion-checkbox","ion-toggle","ion-item-divider","ion-item-group","ion-buttons","ion-select","ion-select-option","ion-input","ion-list-header","ion-list","ion-split-pane","ion-menu"],new i["a"]({render:function(n){return n(I)}}).$mount("#app")}});
//# sourceMappingURL=app.d98a3f6d.js.map