{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/App.vue?763a","webpack:///./src/App.vue?63f4","webpack:///./src/codegen/config.ts","webpack:///./src/codegen/slices-template.ts","webpack:///./src/codegen/slices-comparable-template.ts","webpack:///./src/codegen/slices-timsort-template.ts","webpack:///./src/codegen/slices-comparable-timsort-template.ts","webpack:///./src/codegen/index.ts","webpack:///./src/components/ConfigPanel.vue?9d7f","webpack:///./src/components/ConfigPanel.vue?31cf","webpack:///./src/components/ConfigPanel.vue?5faa","webpack:///./src/components/ConfigPanel.vue","webpack:///./src/App.vue?ec60","webpack:///./src/App.vue?bfbe","webpack:///./src/App.vue","webpack:///./src/registerServiceWorker.ts","webpack:///./src/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","render","_vm","this","_h","$createElement","_c","_self","attrs","model","callback","$$v","config","expression","staticClass","slot","_v","_s","goCode","staticRenderFns","symbol","notPrivateKeyWord","capitalName","toUpperCase","combinedName","funcPrefix","funcSuffix","toLowerCase","generate","packageName","sliceType","sort","binarySearch","indexOf","contains","insert","remove","iterateOver","union","lessThan","generateComparable","generateTimsort","newTimSort","reverseRange","minRunLength","countRunAndMakeAscending","iBinarySort","timSortHandler","gallopLeft","gallopRight","generateComparableTimsort","generateSourceCode","source","acceptLessThan","useTimSort","simpleGoFormat","src","lines","map","line","match","indent","Math","floor","space","Array","join","tab","replace","getPackageName","on","$event","onChangePackageName","getFunctionPrefix","onChangeFunctionPrefix","getFunctionSuffix","onChangeFunctionSuffix","doesUsePrimitiveType","onChangeType","undefined","getSliceType","onChangeSliceType","getPrimitiveSliceType","onChangePrimitiveSliceType","doesAcceptLessThan","onChangeAcceptLessThan","doesUseTimSort","onChangeUseTimSort","pakcageName","functionPrefix","functionSuffix","primitiveSliceType","usePrimitiveType","event","target","emitConfig","checked","input","ConfigPanel","component","updated","elem","document","getElementById","innerHTML","escapeHtml","win","Prism","highlightAll","content","App","components","ready","console","log","registered","cached","updatefound","offline","error","productionTip","ignoredElements","h","$mount"],"mappings":"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","file":"js/app.09bae9a4.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/slices/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('ion-app',[_c('ion-split-pane',{attrs:{\"when\":\"sm\"}},[_c('ion-menu',[_c('ion-content',{attrs:{\"padding\":\"\"}},[_c('ConfigPanel',{model:{value:(_vm.config),callback:function ($$v) {_vm.config=$$v},expression:\"config\"}})],1)],1),_c('ion-page',{staticClass:\"ion-page\",attrs:{\"main\":\"\"}},[_c('ion-header',{attrs:{\"mode\":\"md\"}},[_c('ion-toolbar',{attrs:{\"mode\":\"md\",\"color\":\"primary\"}},[_c('ion-buttons',{attrs:{\"slot\":\"start\"},slot:\"start\"},[_c('ion-menu-toggle',[_c('ion-button',[_c('ion-icon',{attrs:{\"slot\":\"icon-only\",\"name\":\"menu\"},slot:\"icon-only\"})],1)],1)],1),_c('ion-title',[_vm._v(\"Go slice algorithms code generator\")])],1)],1),_c('ion-content',{attrs:{\"padding\":\"\"}},[_c('pre',{staticClass:\"line-numbers\"},[_vm._v(\"            \"),_c('code',{staticClass:\"language-go\",attrs:{\"id\":\"goCode\"}},[_vm._v(_vm._s(_vm.goCode()))]),_vm._v(\"\\n          \")])])],1)],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export type GeneratorConfig = {\n    packageName: string;\n    funcPrefix: string;\n    funcSuffix: string;\n    sliceType: string;\n    acceptLessThan: boolean;\n    useTimSort: boolean;\n};\n\n\nexport function symbol(name: string, notPrivateKeyWord: boolean, config: GeneratorConfig): string {\n    const capitalName = name[0].toUpperCase() + name.slice(1);\n    const combinedName = `${config.funcPrefix}${capitalName}${config.funcSuffix}`;\n    if (!notPrivateKeyWord) {\n        return combinedName[0].toLowerCase() + combinedName.slice(1);\n    }\n    return combinedName;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generate(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const union = symbol('Union', true, config);\n    const lessThan = symbol('LessThan', true, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"sort\"\n    )\n\n    // ${lessThan} is delegate type that sorting uses as a comparator\n    type ${lessThan} func(a, b ${sliceType}) bool\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}, lt ${lessThan}) (err error) {\n        sort.Slice(a, func(i, j int) bool {\n            return lt(a[i], a[j])\n        })\n        return nil\n    }\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if lt(sorted[h], item) {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) bool {\n        i := ${binarySearch}(sorted, item, lt)\n        return !lt(sorted[i], item) && !lt(item, sorted[i])\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if i == len(sorted) - 1 && lt(sorted[i], item) {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(lt ${lessThan}, callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${union} unions sorted slices and returns new slices.\n    func ${union}(lt ${lessThan}, sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if len(sourceSlices) == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n    `;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generateComparable(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const union = symbol('Union', true, config);\n    const lessThan = symbol('LessThan', true, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"sort\"\n    )\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}) (err error) {\n        sort.Slice(a, func(i, j int) bool {\n            return a[i] < a[j]\n        })\n        return nil\n    }\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if sorted[h] < item {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}) int {\n        i := ${binarySearch}(sorted, item, lt)\n        if sorted[i] == item {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}) bool {\n        i := ${binarySearch}(sorted, item, lt)\n        return sorted[i] == item\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if i == len(sorted) - 1 && sorted[i] < item {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if sorted[i] == item {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${union} unions sorted slices and returns new slices.\n    func ${union}(sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if len(sourceSlices) == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n    `;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generateTimsort(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const union = symbol('Union', true, config);\n    const lessThan = symbol('LessThan', true, config);\n\n    const newTimSort = symbol('newTimSort', false, config);\n    const reverseRange = symbol('reverseRange', false, config);\n    const minRunLength = symbol('minRunLength', false, config);\n    const countRunAndMakeAscending = symbol('countRunAndMakeAscending', false, config);\n    const iBinarySort = symbol('binarySort', false, config);\n    const timSortHandler = symbol('timSortHandler', false, config);\n    const gallopLeft = symbol('gallopLeft', false, config);\n    const gallopRight = symbol('gallopRight', false, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"errors\"\n        \"fmt\"\n    )\n\n    // ${lessThan} is delegate type that sorting uses as a comparator\n    type ${lessThan} func(a, b ${sliceType}) bool\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if lt(sorted[h], item) {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) int {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) bool {\n        i := ${binarySearch}(sorted, item, lt)\n        return !lt(sorted[i], item) && !lt(item, sorted[i])\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if i == len(sorted) - 1 && lt(sorted[i], item) {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}, lt ${lessThan}) []${sliceType} {\n        i := ${binarySearch}(sorted, item, lt)\n        if !lt(sorted[i], item) && !lt(item, sorted[i]) {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(lt ${lessThan}, callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${union} unions sorted slices and returns new slices.\n    func ${union}(lt ${lessThan}, sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if len(sourceSlices) == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if lt(sourceSlices[i][indexes[i]], minItem) {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n\n    // timsort code is based on https://github.com/psilva261/timsort\n    //\n    // Package timsort provides fast stable sort, uses external comparator.\n    //\n    // A stable, adaptive, iterative mergesort that requires far fewer than\n    // n lg(n) comparisons when running on partially sorted arrays, while\n    // offering performance comparable to a traditional mergesort when run\n    // on random arrays.  Like all proper mergesorts, this sort is stable and\n    // runs O(n log n) time (worst case).  In the worst case, this sort requires\n    // temporary storage space for n/2 object references; in the best case,\n    // it requires only a small constant amount of space.\n    //\n    // This implementation was derived from Java's TimSort object by Josh Bloch,\n    // which, in turn, was based on the original code by Tim Peters:\n    //\n    // http://svn.python.org/projects/python/trunk/Objects/listsort.txt\n    //\n    // Mike K.\n    // ${lessThan} is Delegate type that sorting uses as a comparator\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}, lt ${lessThan}) (err error) {\n        const minMerge = 32\n        lo := 0\n        hi := len(a)\n        nRemaining := hi\n        if nRemaining < 2 {\n            return\n        }\n        if nRemaining < minMerge {\n            initRunLen, err := ${countRunAndMakeAscending}(a, lo, hi, lt)\n            if err != nil {\n                return err\n            }\n            return ${iBinarySort}(a, lo, hi, lo+initRunLen, lt)\n        }\n        ts := ${newTimSort}(a, lt)\n        minRun, err := ${minRunLength}(nRemaining)\n        if err != nil {\n            return\n        }\n        for {\n            runLen, err := ${countRunAndMakeAscending}(a, lo, hi, lt)\n            if err != nil {\n                return err\n            }\n            if runLen < minRun {\n                force := minRun\n                if nRemaining <= minRun {\n                    force = nRemaining\n                }\n                if err = ${iBinarySort}(a, lo, lo+force, lo+runLen, lt); err != nil {\n                    return err\n                }\n                runLen = force\n            }\n            ts.pushRun(lo, runLen)\n            if err = ts.mergeCollapse(); err != nil {\n                return err\n            }\n            lo += runLen\n            nRemaining -= runLen\n            if nRemaining == 0 {\n                break\n            }\n        }\n        if lo != hi {\n            return errors.New(\"lo must equal hi\")\n        }\n        if err = ts.mergeForceCollapse(); err != nil {\n            return\n        }\n        if ts.stackSize != 1 {\n            return errors.New(\"ts.stackSize != 1\")\n        }\n        return\n    }\n\n    type ${timSortHandler} struct {\n        a []${sliceType}\n        lt ${lessThan}\n        minGallop int\n        tmp []${sliceType} // Actual runtime type will be Object[], regardless of ${sliceType}\n        stackSize int // Number of pending runs on stack\n        runBase   []int\n        runLen    []int\n    }\n\n    func ${newTimSort}(a []${sliceType}, lt ${lessThan}) (h *${timSortHandler}) {\n        minGallop := 7\n        initialTmpStorageLength := 256\n        h = new(${timSortHandler})\n\n        h.a = a\n        h.lt = lt\n        h.minGallop = minGallop\n        h.stackSize = 0\n        len := len(a)\n\n        tmpSize := initialTmpStorageLength\n        if len < 2*tmpSize {\n            tmpSize = len / 2\n        }\n\n        h.tmp = make([]${sliceType}, tmpSize)\n        stackLen := 40\n        if len < 120 {\n            stackLen = 5\n        } else if len < 1542 {\n            stackLen = 10\n        } else if len < 119151 {\n            stackLen = 19\n        }\n\n        h.runBase = make([]int, stackLen)\n        h.runLen = make([]int, stackLen)\n\n        return h\n    }\n\n    func ${iBinarySort}(a []${sliceType}, lo, hi, start int, lt ${lessThan}) (err error) {\n        if lo > start || start > hi {\n            return errors.New(\"lo <= start && start <= hi\")\n        }\n\n        if start == lo {\n            start++\n        }\n\n        for ; start < hi; start++ {\n            pivot := a[start]\n            left := lo\n            right := start\n            if left > right {\n                return errors.New(\"left <= right\")\n            }\n            for left < right {\n                mid := int(uint(left+right) >> 1)\n                if lt(pivot, a[mid]) {\n                    right = mid\n                } else {\n                    left = mid + 1\n                }\n            }\n            if left != right {\n                return errors.New(\"left == right\")\n            }\n            n := start - left // The number of elements to move\n            if n <= 2 {\n                if n == 2 {\n                    a[left+2] = a[left+1]\n                }\n                if n > 0 {\n                    a[left+1] = a[left]\n                }\n            } else {\n                copy(a[left+1:], a[left:left+n])\n            }\n            a[left] = pivot\n        }\n        return\n    }\n\n    func ${countRunAndMakeAscending}(a []${sliceType}, lo, hi int, lt ${lessThan}) (int, error) {\n        if lo >= hi {\n            return 0, errors.New(\"lo < hi\")\n        }\n        runHi := lo + 1\n        if runHi == hi {\n            return 1, nil\n        }\n        if lt(a[runHi], a[lo]) {\n            runHi++\n            for runHi < hi && lt(a[runHi], a[runHi-1]) {\n                runHi++\n            }\n            ${reverseRange}(a, lo, runHi)\n        } else {\n            for runHi < hi && !lt(a[runHi], a[runHi-1]) {\n                runHi++\n            }\n        }\n        return runHi - lo, nil\n    }\n\n    func ${reverseRange}(a []${sliceType}, lo, hi int) {\n        hi--\n        for lo < hi {\n            a[lo], a[hi] = a[hi], a[lo]\n            lo++\n            hi--\n        }\n    }\n\n    func ${minRunLength}(n int) (int, error) {\n        const minMerge = 32\n        if n < 0 {\n            return 0, errors.New(\"n >= 0\")\n        }\n        r := 0 // Becomes 1 if any 1 bits are shifted off\n        for n >= minMerge {\n            r |= (n & 1)\n            n >>= 1\n        }\n        return n + r, nil\n    }\n\n    func (h *${timSortHandler}) pushRun(runBase, runLen int) {\n        h.runBase[h.stackSize] = runBase\n        h.runLen[h.stackSize] = runLen\n        h.stackSize++\n    }\n\n    func (h *${timSortHandler}) mergeCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if (n > 0 && h.runLen[n-1] <= h.runLen[n]+h.runLen[n+1]) ||\n                (n > 1 && h.runLen[n-2] <= h.runLen[n-1]+h.runLen[n]) {\n                if h.runLen[n-1] < h.runLen[n+1] {\n                    n--\n                }\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else if h.runLen[n] <= h.runLen[n+1] {\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else {\n                break\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeForceCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if n > 0 && h.runLen[n-1] < h.runLen[n+1] {\n                n--\n            }\n            if err = h.mergeAt(n); err != nil {\n                return\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeAt(i int) (err error) {\n        if h.stackSize < 2 {\n            return errors.New(\"stackSize >= 2\")\n        }\n        if i < 0 {\n            return errors.New(\" i >= 0\")\n        }\n        if i != h.stackSize-2 && i != h.stackSize-3 {\n            return errors.New(\"if i == stackSize - 2 || i == stackSize - 3\")\n        }\n        base1 := h.runBase[i]\n        len1 := h.runLen[i]\n        base2 := h.runBase[i+1]\n        len2 := h.runLen[i+1]\n        if len1 <= 0 || len2 <= 0 {\n            return errors.New(\"len1 > 0 && len2 > 0\")\n        }\n        if base1+len1 != base2 {\n            return errors.New(\"base1 + len1 == base2\")\n        }\n        h.runLen[i] = len1 + len2\n        if i == h.stackSize-3 {\n            h.runBase[i+1] = h.runBase[i+2]\n            h.runLen[i+1] = h.runLen[i+2]\n        }\n        h.stackSize--\n        k, err := ${gallopRight}(h.a[base2], h.a, base1, len1, 0, h.lt)\n        if err != nil {\n            return err\n        }\n        if k < 0 {\n            return errors.New(\" k >= 0;\")\n        }\n        base1 += k\n        len1 -= k\n        if len1 == 0 {\n            return\n        }\n        len2, err = ${gallopLeft}(h.a[base1+len1-1], h.a, base2, len2, len2-1, h.lt)\n        if err != nil {\n            return\n        }\n        if len2 < 0 {\n            return errors.New(\" len2 >= 0;\")\n        }\n        if len2 == 0 {\n            return\n        }\n        if len1 <= len2 {\n            err = h.mergeLo(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeLo: %v\", err)\n            }\n        } else {\n            err = h.mergeHi(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeHi: %v\", err)\n            }\n        }\n        return\n    }\n\n    func ${gallopLeft}(key ${sliceType}, a []${sliceType}, base, len, hint int, c ${lessThan}) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n        lastOfs := 0\n        ofs := 1\n\n        if c(a[base+hint], key) {\n            maxOfs := len - hint\n            for ofs < maxOfs && c(a[base+hint+ofs], key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        } else {\n            maxOfs := hint + 1\n            for ofs < maxOfs && !c(a[base+hint-ofs], key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\" -1 <= lastOfs && lastOfs < ofs && ofs <= len;\")\n        }\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if c(a[base+m], key) {\n                lastOfs = m + 1\n            } else {\n                ofs = m\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\")\n        }\n        return ofs, nil\n    }\n\n    func ${gallopRight}(key ${sliceType}, a []${sliceType}, base, len, hint int, c ${lessThan}) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n\n        ofs := 1\n        lastOfs := 0\n        if c(key, a[base+hint]) {\n            maxOfs := hint + 1\n            for ofs < maxOfs && c(key, a[base+hint-ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        } else {\n            maxOfs := len - hint\n            for ofs < maxOfs && !c(key, a[base+hint+ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 {\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\"-1 <= lastOfs && lastOfs < ofs && ofs <= len\")\n        }\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if c(key, a[base+m]) {\n                ofs = m\n            } else {\n                lastOfs = m + 1\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\")\n        }\n        return ofs, nil\n    }\n\n    func (h *${timSortHandler}) mergeLo(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\" len1 > 0 && len2 > 0 && base1 + len1 == base2\")\n        }\n        a := h.a\n        tmp := h.ensureCapacity(len1)\n        copy(tmp, a[base1:base1+len1])\n        cursor1 := 0\n        cursor2 := base2\n        dest := base1\n        a[dest] = a[cursor2]\n        dest++\n        cursor2++\n        len2--\n        if len2 == 0 {\n            copy(a[dest:dest+len1], tmp)\n            return\n        }\n        if len1 == 1 {\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1]\n            return\n        }\n        lt := h.lt\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0\n            count2 := 0\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\" len1 > 1 && len2 > 0\")\n                }\n\n                if lt(a[cursor2], tmp[cursor1]) {\n                    a[dest] = a[cursor2]\n                    dest++\n                    cursor2++\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor1]\n                    dest++\n                    cursor1++\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\"len1 > 1 && len2 > 0\")\n                }\n                count1, err = ${gallopRight}(a[cursor2], tmp, cursor1, len1, 0, lt)\n                if err != nil {\n                    return\n                }\n                if count1 != 0 {\n                    copy(a[dest:dest+count1], tmp[cursor1:cursor1+count1])\n                    dest += count1\n                    cursor1 += count1\n                    len1 -= count1\n                    if len1 <= 1 {\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor2]\n                dest++\n                cursor2++\n                len2--\n                if len2 == 0 {\n                    break outer\n                }\n                count2, err = ${gallopLeft}(tmp[cursor1], a, cursor2, len2, 0, lt)\n                if err != nil {\n                    return\n                }\n                if count2 != 0 {\n                    copy(a[dest:dest+count2], a[cursor2:cursor2+count2])\n                    dest += count2\n                    cursor2 += count2\n                    len2 -= count2\n                    if len2 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor1]\n                dest++\n                cursor1++\n                len1--\n                if len1 == 1 {\n                    break outer\n                }\n                minGallop--\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2\n        }\n        if minGallop < 1 {\n            minGallop = 1\n        }\n        h.minGallop = minGallop\n        if len1 == 1 {\n\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1]\n        } else if len1 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len2 != 0 {\n                return errors.New(\"len2 == 0;\")\n            }\n            if len1 <= 1 {\n                return errors.New(\" len1 > 1;\")\n            }\n            copy(a[dest:dest+len1], tmp[cursor1:cursor1+len1])\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeHi(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\"len1 > 0 && len2 > 0 && base1 + len1 == base2;\")\n        }\n        a := h.a\n        tmp := h.ensureCapacity(len2)\n        copy(tmp, a[base2:base2+len2])\n        cursor1 := base1 + len1 - 1\n        cursor2 := len2 - 1\n        dest := base2 + len2 - 1\n        a[dest] = a[cursor1]\n        dest--\n        cursor1--\n        len1--\n        if len1 == 0 {\n            dest -= len2 - 1\n            copy(a[dest:dest+len2], tmp)\n            return\n        }\n        if len2 == 1 {\n            dest -= len1 - 1\n            cursor1 -= len1 - 1\n            copy(a[dest:dest+len1], a[cursor1:cursor1+len1])\n            a[dest-1] = tmp[cursor2]\n            return\n        }\n        lt := h.lt\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if lt(tmp[cursor2], a[cursor1]) {\n                    a[dest] = a[cursor1]\n                    dest--\n                    cursor1--\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor2]\n                    dest--\n                    cursor2--\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if gr, err := ${gallopRight}(tmp[cursor2], a, base1, len1, len1-1, lt); err == nil {\n                    count1 = len1 - gr\n                } else {\n                    return err\n                }\n                if count1 != 0 {\n                    dest -= count1\n                    cursor1 -= count1\n                    len1 -= count1\n                    copy(a[dest+1:dest+1+count1], a[cursor1+1:cursor1+1+count1])\n                    if len1 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor2]\n                dest--\n                cursor2--\n                len2--\n                if len2 == 1 {\n                    break outer\n                }\n\n                if gl, err := ${gallopLeft}(a[cursor1], tmp, 0, len2, len2-1, lt); err == nil {\n                    count2 = len2 - gl\n                } else {\n                    return err\n                }\n                if count2 != 0 {\n                    dest -= count2\n                    cursor2 -= count2\n                    len2 -= count2\n                    copy(a[dest+1:dest+1+count2], tmp[cursor2+1:cursor2+1+count2])\n                    if len2 <= 1 { // len2 == 1 || len2 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor1]\n                dest--\n                cursor1--\n                len1--\n                if len1 == 0 {\n                    break outer\n                }\n                minGallop--\n\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        } // End of \"outer\" loop\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n\n        h.minGallop = minGallop // Write back to field\n\n        if len2 == 1 {\n            if len1 <= 0 {\n                return errors.New(\" len1 > 0;\")\n            }\n            dest -= len1\n            cursor1 -= len1\n\n            copy(a[dest+1:dest+1+len1], a[cursor1+1:cursor1+1+len1])\n            a[dest] = tmp[cursor2] // Move first elt of run2 to front of merge\n        } else if len2 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len1 != 0 {\n                return errors.New(\"len1 == 0;\")\n            }\n\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n\n            copy(a[dest-(len2-1):dest+1], tmp)\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) ensureCapacity(minCapacity int) []${sliceType} {\n        if len(h.tmp) < minCapacity {\n            // Compute smallest power of 2 > minCapacity\n            newSize := minCapacity\n            newSize |= newSize >> 1\n            newSize |= newSize >> 2\n            newSize |= newSize >> 4\n            newSize |= newSize >> 8\n            newSize |= newSize >> 16\n            newSize++\n\n            if newSize < 0 { // Not bloody likely!\n                newSize = minCapacity\n            } else {\n                ns := len(h.a) / 2\n                if ns < newSize {\n                    newSize = ns\n                }\n            }\n\n            h.tmp = make([]${sliceType}, newSize)\n        }\n\n        return h.tmp\n    }\n    `;\n}\n","import { GeneratorConfig, symbol } from './config';\n\nexport function generateComparableTimsort(config: GeneratorConfig): string {\n    const { packageName, sliceType } = config;\n    const sort = symbol('Sort', true, config);\n    const binarySearch = symbol('BinarySearch', true, config);\n    const indexOf = symbol('IndexOf', true, config);\n    const contains = symbol('Contains', true, config);\n    const insert = symbol('Insert', true, config);\n    const remove = symbol('Remove', true, config);\n    const iterateOver = symbol('IterateOver', true, config);\n    const union = symbol('Union', true, config);\n\n    const countRunAndMakeAscending = symbol('countRunAndMakeAscending', false, config);\n    const reverseRange = symbol('reverseRange', false, config);\n    const minRunLength = symbol('minRunLength', false, config);\n    const iBinarySort = symbol('binarySort', false, config);\n    const timSortHandler = symbol('timSortHandler', false, config);\n    const gallopLeft = symbol('gallopLeft', false, config);\n    const gallopRight = symbol('gallopRight', false, config);\n\n    return `\n    package ${packageName}\n\n    import (\n        \"errors\"\n        \"fmt\"\n    )\n\n    // ${binarySearch} returns first index i that satisfies slices[i] <= item.\n    func ${binarySearch}(sorted []${sliceType}, item ${sliceType}) int {\n        // Define f(-1) == false and f(n) == true.\n        // Invariant: f(i-1) == false, f(j) == true.\n        i, j := 0, len(sorted) - 1\n        for i < j {\n            h := int(uint(i+j) >> 1) // avoid overflow when computing h\n            // i ≤ h < j\n            if sorted[h] < item {\n                i = h + 1 // preserves f(i-1) == false\n            } else {\n                j = h // preserves f(j) == true\n            }\n        }\n        // i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.\n        return i\n    }\n\n    // ${indexOf} returns index of item. If item is not in a sorted slice, it returns -1.\n    func ${indexOf}(sorted []${sliceType}, item ${sliceType}) int {\n        i := ${binarySearch}(sorted, item)\n        if sorted[i] == item {\n            return i\n        }\n        return -1\n    }\n\n    // ${contains} returns true if item is in a sorted slice. Otherwise false.\n    func ${contains}(sorted []${sliceType}, item ${sliceType}) bool {\n        i := ${binarySearch}(sorted, item)\n        return sorted[i] == item\n    }\n\n    // ${insert} inserts item in correct position and returns a sorted slice.\n    func ${insert}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item)\n        if i == len(sorted) - 1 && sorted[i] < item {\n            return append(sorted, item)\n        }\n        return append(sorted[:i], append([]${sliceType}{item}, sorted[i:]...)...)\n    }\n\n    // ${remove} removes item in a sorted slice.\n    func ${remove}(sorted []${sliceType}, item ${sliceType}) []${sliceType} {\n        i := ${binarySearch}(sorted, item)\n        if sorted[i] == item {\n            return append(sorted[:i], sorted[i+1:]...)\n        }\n        return sorted\n    }\n\n    // ${iterateOver} iterates over input sorted slices and calls callback with each items in ascendant order.\n    func ${iterateOver}(callback func(item ${sliceType}, srcIndex int), sorted ...[]${sliceType}) {\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        sourceSliceCount := len(sourceSlices)\n        if sourceSliceCount == 0 {\n            return\n        } else if sourceSliceCount == 1 {\n            for i, value := range sourceSlices[0] {\n                callback(value, i)\n            }\n            return\n        }\n        indexes := make([]int, sourceSliceCount)\n        sliceIndex := make([]int, sourceSliceCount)\n        for i := range sourceSlices {\n            sliceIndex[i] = i\n        }\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            callback(minItem, sliceIndex[minSlice])\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    slice := sourceSlices[0]\n                    for i := indexes[0]; i < len(slice); i++ {\n                        callback(slice[i], sliceIndex[0])\n                    }\n                    return\n                }\n            }\n        }\n    }\n\n    // ${union} unions sorted slices and returns new slices.\n    func ${union}(sorted ...[]${sliceType}) []${sliceType} {\n        length := 0\n        sourceSlices := make([][]${sliceType}, 0, len(sorted))\n        for _, src := range sorted {\n            if len(src) > 0 {\n                length += len(src)\n                sourceSlices = append(sourceSlices, src)\n            }\n        }\n        if length == 0 {\n            return nil\n        } else if len(sourceSlices) == 1 {\n            return sourceSlices[0]\n        }\n        result := make([]${sliceType}, length)\n        sourceSliceCount := len(sourceSlices)\n        indexes := make([]int, sourceSliceCount)\n        index := 0\n        for {\n            minSlice := 0\n            minItem := sourceSlices[0][indexes[0]]\n            for i := 1; i < sourceSliceCount; i++ {\n                if sourceSlices[i][indexes[i]] < minItem {\n                    minSlice = i\n                    minItem = sourceSlices[i][indexes[i]]\n                }\n            }\n            result[index] = minItem\n            index++\n            indexes[minSlice]++\n            if indexes[minSlice] == len(sourceSlices[minSlice]) {\n                sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)\n                indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)\n                sourceSliceCount--\n                if len(sourceSlices) == 1 {\n                    copy(result[index:], sourceSlices[0][indexes[0]:])\n                    return result\n                }\n            }\n        }\n    }\n\n    // timsort code is based on https://github.com/psilva261/timsort\n    //\n    // Package timsort provides fast stable sort, uses external comparator.\n    //\n    // A stable, adaptive, iterative mergesort that requires far fewer than\n    // n lg(n) comparisons when running on partially sorted arrays, while\n    // offering performance comparable to a traditional mergesort when run\n    // on random arrays.  Like all proper mergesorts, this sort is stable and\n    // runs O(n log n) time (worst case).  In the worst case, this sort requires\n    // temporary storage space for n/2 object references; in the best case,\n    // it requires only a small constant amount of space.\n    //\n    // This implementation was derived from Java's TimSort object by Josh Bloch,\n    // which, in turn, was based on the original code by Tim Peters:\n    //\n    // http://svn.python.org/projects/python/trunk/Objects/listsort.txt\n    //\n    // Mike K.\n\n    // ${sort} sorts an array using the provided comparator\n    func ${sort}(a []${sliceType}) (err error) {\n        minMerge := 32\n        lo := 0\n        hi := len(a)\n        nRemaining := hi\n\n        if nRemaining < 2 {\n            return // Arrays of size 0 and 1 are always sorted\n        }\n\n        if nRemaining < minMerge {\n            initRunLen, err := ${countRunAndMakeAscending}(a, lo, hi)\n            if err != nil {\n                return err\n            }\n            return ${iBinarySort}(a, lo, hi, lo+initRunLen)\n        }\n        ts := ${symbol('newTimSort', false, config)}(a)\n        minRun, err := ${minRunLength}(nRemaining)\n        if err != nil {\n            return\n        }\n        for {\n            // Identify next run\n            runLen, err := ${countRunAndMakeAscending}(a, lo, hi)\n            if err != nil {\n                return err\n            }\n            if runLen < minRun {\n                force := minRun\n                if nRemaining <= minRun {\n                    force = nRemaining\n                }\n                if err = ${iBinarySort}(a, lo, lo+force, lo+runLen); err != nil {\n                    return err\n                }\n                runLen = force\n            }\n            ts.pushRun(lo, runLen)\n            if err = ts.mergeCollapse(); err != nil {\n                return err\n            }\n            lo += runLen\n            nRemaining -= runLen\n            if nRemaining == 0 {\n                break\n            }\n        }\n        if lo != hi {\n            return errors.New(\"lo must equal hi\")\n        }\n        if err = ts.mergeForceCollapse(); err != nil {\n            return\n        }\n        if ts.stackSize != 1 {\n            return errors.New(\"ts.stackSize != 1\")\n        }\n        return\n    }\n\n    type ${timSortHandler} struct {\n        a []${sliceType}\n        minGallop int\n        tmp []${sliceType}\n        stackSize int\n        runBase   []int\n        runLen    []int\n    }\n\n    func ${symbol('newTimSort', false, config)}(a []${sliceType}) (h *${timSortHandler}) {\n        minGallop := 7\n        initialTmpStorageLength := 256\n        h = new(${timSortHandler})\n\n        h.a = a\n        h.minGallop = minGallop\n        h.stackSize = 0\n        len := len(a)\n        tmpSize := initialTmpStorageLength\n        if len < 2*tmpSize {\n            tmpSize = len / 2\n        }\n        h.tmp = make([]${sliceType}, tmpSize)\n        stackLen := 40\n        if len < 120 {\n            stackLen = 5\n        } else if len < 1542 {\n            stackLen = 10\n        } else if len < 119151 {\n            stackLen = 19\n        }\n        h.runBase = make([]int, stackLen)\n        h.runLen = make([]int, stackLen)\n        return h\n    }\n\n    func ${iBinarySort}(a []${sliceType}, lo, hi, start int) (err error) {\n        if lo > start || start > hi {\n            return errors.New(\"lo <= start && start <= hi\")\n        }\n        if start == lo {\n            start++\n        }\n        for ; start < hi; start++ {\n            pivot := a[start]\n            left := lo\n            right := start\n            if left > right {\n                return errors.New(\"left <= right\")\n            }\n            for left < right {\n                mid := int(uint(left+right) >> 1)\n                if pivot < a[mid] {\n                    right = mid\n                } else {\n                    left = mid + 1\n                }\n            }\n            if left != right {\n                return errors.New(\"left == right\")\n            }\n            n := start - left // The number of elements to move\n            // just an optimization for copy in default case\n            if n <= 2 {\n                if n == 2 {\n                    a[left+2] = a[left+1]\n                }\n                if n > 0 {\n                    a[left+1] = a[left]\n                }\n            } else {\n                copy(a[left+1:], a[left:left+n])\n            }\n            a[left] = pivot\n        }\n        return\n    }\n\n    func ${countRunAndMakeAscending}(a []${sliceType}, lo, hi int) (int, error) {\n        if lo >= hi {\n            return 0, errors.New(\"lo < hi\")\n        }\n        runHi := lo + 1\n        if runHi == hi {\n            return 1, nil\n        }\n        if a[runHi] < a[lo] { // Descending\n            runHi++\n            for runHi < hi && a[runHi] < a[runHi-1] {\n                runHi++\n            }\n            ${reverseRange}(a, lo, runHi)\n        } else { // Ascending\n            for runHi < hi && !(a[runHi] < a[runHi-1]) {\n                runHi++\n            }\n        }\n        return runHi - lo, nil\n    }\n\n    func ${reverseRange}(a []${sliceType}, lo, hi int) {\n        hi--\n        for lo < hi {\n            a[lo], a[hi] = a[hi], a[lo]\n            lo++\n            hi--\n        }\n    }\n\n    func ${minRunLength}(n int) (int, error) {\n        minMerge := 32\n        if n < 0 {\n            return 0, errors.New(\"n >= 0\")\n        }\n        r := 0 // Becomes 1 if any 1 bits are shifted off\n        for n >= minMerge {\n            r |= (n & 1)\n            n >>= 1\n        }\n        return n + r, nil\n    }\n\n    func (h *${timSortHandler}) pushRun(runBase, runLen int) {\n        h.runBase[h.stackSize] = runBase\n        h.runLen[h.stackSize] = runLen\n        h.stackSize++\n    }\n\n    func (h *${timSortHandler}) mergeCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if (n > 0 && h.runLen[n-1] <= h.runLen[n]+h.runLen[n+1]) ||\n                (n > 1 && h.runLen[n-2] <= h.runLen[n-1]+h.runLen[n]) {\n                if h.runLen[n-1] < h.runLen[n+1] {\n                    n--\n                }\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else if h.runLen[n] <= h.runLen[n+1] {\n                if err = h.mergeAt(n); err != nil {\n                    return\n                }\n            } else {\n                break // Invariant is established\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeForceCollapse() (err error) {\n        for h.stackSize > 1 {\n            n := h.stackSize - 2\n            if n > 0 && h.runLen[n-1] < h.runLen[n+1] {\n                n--\n            }\n            if err = h.mergeAt(n); err != nil {\n                return\n            }\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeAt(i int) (err error) {\n        if h.stackSize < 2 {\n            return errors.New(\"stackSize >= 2\")\n        }\n\n        if i < 0 {\n            return errors.New(\" i >= 0\")\n        }\n\n        if i != h.stackSize-2 && i != h.stackSize-3 {\n            return errors.New(\"if i == stackSize - 2 || i == stackSize - 3\")\n        }\n\n        base1 := h.runBase[i]\n        len1 := h.runLen[i]\n        base2 := h.runBase[i+1]\n        len2 := h.runLen[i+1]\n\n        if len1 <= 0 || len2 <= 0 {\n            return errors.New(\"len1 > 0 && len2 > 0\")\n        }\n\n        if base1+len1 != base2 {\n            return errors.New(\"base1 + len1 == base2\")\n        }\n\n        h.runLen[i] = len1 + len2\n        if i == h.stackSize-3 {\n            h.runBase[i+1] = h.runBase[i+2]\n            h.runLen[i+1] = h.runLen[i+2]\n        }\n        h.stackSize--\n\n        k, err := ${gallopRight}(h.a[base2], h.a, base1, len1, 0)\n        if err != nil {\n            return err\n        }\n        if k < 0 {\n            return errors.New(\" k >= 0;\")\n        }\n        base1 += k\n        len1 -= k\n        if len1 == 0 {\n            return\n        }\n\n        len2, err = ${gallopLeft}(h.a[base1+len1-1], h.a, base2, len2, len2-1)\n        if err != nil {\n            return\n        }\n        if len2 < 0 {\n            return errors.New(\" len2 >= 0;\")\n        }\n        if len2 == 0 {\n            return\n        }\n\n        if len1 <= len2 {\n            err = h.mergeLo(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeLo: %v\", err)\n            }\n        } else {\n            err = h.mergeHi(base1, len1, base2, len2)\n            if err != nil {\n                return fmt.Errorf(\"mergeHi: %v\", err)\n            }\n        }\n        return\n    }\n\n    func ${gallopLeft}(key ${sliceType}, a []${sliceType}, base, len, hint int) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n        lastOfs := 0\n        ofs := 1\n\n        if a[base+hint] < key {\n            // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]\n            maxOfs := len - hint\n            for ofs < maxOfs && a[base+hint+ofs] < key {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            lastOfs += hint\n            ofs += hint\n        } else { // key <= a[base + hint]\n            // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]\n            maxOfs := hint + 1\n            for ofs < maxOfs && !(a[base+hint-ofs] < key) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        }\n\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\" -1 <= lastOfs && lastOfs < ofs && ofs <= len;\")\n        }\n\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n            if a[base+m] < key {\n                lastOfs = m + 1 // a[base + m] < key\n            } else {\n                ofs = m // key <= a[base + m]\n            }\n        }\n\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\") // so a[base + ofs - 1] < key <= a[base + ofs]\n        }\n        return ofs, nil\n    }\n\n    func ${gallopRight}(key ${sliceType}, a []${sliceType}, base, len, hint int) (int, error) {\n        if len <= 0 || hint < 0 || hint >= len {\n            return 0, errors.New(\" len > 0 && hint >= 0 && hint < len;\")\n        }\n        ofs := 1\n        lastOfs := 0\n        if key < a[base+hint] {\n            // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]\n            maxOfs := hint + 1\n            for ofs < maxOfs && key < a[base+hint-ofs] {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n\n            tmp := lastOfs\n            lastOfs = hint - ofs\n            ofs = hint - tmp\n        } else { // a[b + hint] <= key\n            // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]\n            maxOfs := len - hint\n            for ofs < maxOfs && !(key < a[base+hint+ofs]) {\n                lastOfs = ofs\n                ofs = (ofs << 1) + 1\n                if ofs <= 0 { // int overflow\n                    ofs = maxOfs\n                }\n            }\n            if ofs > maxOfs {\n                ofs = maxOfs\n            }\n\n            lastOfs += hint\n            ofs += hint\n        }\n        if -1 > lastOfs || lastOfs >= ofs || ofs > len {\n            return 0, errors.New(\"-1 <= lastOfs && lastOfs < ofs && ofs <= len\")\n        }\n\n        lastOfs++\n        for lastOfs < ofs {\n            m := lastOfs + (ofs-lastOfs)/2\n\n            if key < a[base+m] {\n                ofs = m // key < a[b + m]\n            } else {\n                lastOfs = m + 1 // a[b + m] <= key\n            }\n        }\n        if lastOfs != ofs {\n            return 0, errors.New(\" lastOfs == ofs\") // so a[b + ofs - 1] <= key < a[b + ofs]\n        }\n        return ofs, nil\n    }\n\n    func (h *${timSortHandler}) mergeLo(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\" len1 > 0 && len2 > 0 && base1 + len1 == base2\")\n        }\n\n        a := h.a // For performance\n        tmp := h.ensureCapacity(len1)\n\n        copy(tmp, a[base1:base1+len1])\n\n        cursor1 := 0     // Indexes into tmp array\n        cursor2 := base2 // Indexes int a\n        dest := base1    // Indexes int a\n\n        a[dest] = a[cursor2]\n        dest++\n        cursor2++\n        len2--\n        if len2 == 0 {\n            copy(a[dest:dest+len1], tmp)\n            return\n        }\n        if len1 == 1 {\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1] // Last elt of run 1 to end of merge\n            return\n        }\n\n        minGallop := h.minGallop\n\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\" len1 > 1 && len2 > 0\")\n                }\n\n                if a[cursor2] < tmp[cursor1] {\n                    a[dest] = a[cursor2]\n                    dest++\n                    cursor2++\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor1]\n                    dest++\n                    cursor1++\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n\n            for {\n                if len1 <= 1 || len2 <= 0 {\n                    return errors.New(\"len1 > 1 && len2 > 0\")\n                }\n                count1, err = ${gallopRight}(a[cursor2], tmp, cursor1, len1, 0)\n                if err != nil {\n                    return\n                }\n                if count1 != 0 {\n                    copy(a[dest:dest+count1], tmp[cursor1:cursor1+count1])\n                    dest += count1\n                    cursor1 += count1\n                    len1 -= count1\n                    if len1 <= 1 { // len1 == 1 || len1 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor2]\n                dest++\n                cursor2++\n                len2--\n                if len2 == 0 {\n                    break outer\n                }\n\n                count2, err = ${gallopLeft}(tmp[cursor1], a, cursor2, len2, 0)\n                if err != nil {\n                    return\n                }\n                if count2 != 0 {\n                    copy(a[dest:dest+count2], a[cursor2:cursor2+count2])\n                    dest += count2\n                    cursor2 += count2\n                    len2 -= count2\n                    if len2 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor1]\n                dest++\n                cursor1++\n                len1--\n                if len1 == 1 {\n                    break outer\n                }\n                minGallop--\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        }\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n        h.minGallop = minGallop // Write back to field\n\n        if len1 == 1 {\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n            copy(a[dest:dest+len2], a[cursor2:cursor2+len2])\n            a[dest+len2] = tmp[cursor1] //  Last elt of run 1 to end of merge\n        } else if len1 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len2 != 0 {\n                return errors.New(\"len2 == 0;\")\n            }\n            if len1 <= 1 {\n                return errors.New(\" len1 > 1;\")\n            }\n\n            copy(a[dest:dest+len1], tmp[cursor1:cursor1+len1])\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) mergeHi(base1, len1, base2, len2 int) (err error) {\n        if len1 <= 0 || len2 <= 0 || base1+len1 != base2 {\n            return errors.New(\"len1 > 0 && len2 > 0 && base1 + len1 == base2;\")\n        }\n\n        a := h.a // For performance\n        tmp := h.ensureCapacity(len2)\n\n        copy(tmp, a[base2:base2+len2])\n\n        cursor1 := base1 + len1 - 1 // Indexes into a\n        cursor2 := len2 - 1         // Indexes into tmp array\n        dest := base2 + len2 - 1    // Indexes into a\n\n        a[dest] = a[cursor1]\n        dest--\n        cursor1--\n        len1--\n        if len1 == 0 {\n            dest -= len2 - 1\n            copy(a[dest:dest+len2], tmp)\n            return\n        }\n        if len2 == 1 {\n            dest -= len1 - 1\n            cursor1 -= len1 - 1\n            copy(a[dest:dest+len1], a[cursor1:cursor1+len1])\n            a[dest-1] = tmp[cursor2]\n            return\n        }\n        minGallop := h.minGallop\n    outer:\n        for {\n            count1 := 0 // Number of times in a row that first run won\n            count2 := 0 // Number of times in a row that second run won\n\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if tmp[cursor2] < a[cursor1] {\n                    a[dest] = a[cursor1]\n                    dest--\n                    cursor1--\n                    count1++\n                    count2 = 0\n                    len1--\n                    if len1 == 0 {\n                        break outer\n                    }\n                } else {\n                    a[dest] = tmp[cursor2]\n                    dest--\n                    cursor2--\n                    count2++\n                    count1 = 0\n                    len2--\n                    if len2 == 1 {\n                        break outer\n                    }\n                }\n                if (count1 | count2) >= minGallop {\n                    break\n                }\n            }\n\n            for {\n                if len1 <= 0 || len2 <= 1 {\n                    return errors.New(\" len1 > 0 && len2 > 1;\")\n                }\n                if gr, err := ${gallopRight}(tmp[cursor2], a, base1, len1, len1-1); err == nil {\n                    count1 = len1 - gr\n                } else {\n                    return err\n                }\n                if count1 != 0 {\n                    dest -= count1\n                    cursor1 -= count1\n                    len1 -= count1\n                    copy(a[dest+1:dest+1+count1], a[cursor1+1:cursor1+1+count1])\n                    if len1 == 0 {\n                        break outer\n                    }\n                }\n                a[dest] = tmp[cursor2]\n                dest--\n                cursor2--\n                len2--\n                if len2 == 1 {\n                    break outer\n                }\n\n                if gl, err := ${gallopLeft}(a[cursor1], tmp, 0, len2, len2-1); err == nil {\n                    count2 = len2 - gl\n                } else {\n                    return err\n                }\n                if count2 != 0 {\n                    dest -= count2\n                    cursor2 -= count2\n                    len2 -= count2\n                    copy(a[dest+1:dest+1+count2], tmp[cursor2+1:cursor2+1+count2])\n                    if len2 <= 1 { // len2 == 1 || len2 == 0\n                        break outer\n                    }\n                }\n                a[dest] = a[cursor1]\n                dest--\n                cursor1--\n                len1--\n                if len1 == 0 {\n                    break outer\n                }\n                minGallop--\n\n                if count1 < minGallop && count2 < minGallop {\n                    break\n                }\n            }\n            if minGallop < 0 {\n                minGallop = 0\n            }\n            minGallop += 2 // Penalize for leaving gallop mode\n        } // End of \"outer\" loop\n\n        if minGallop < 1 {\n            minGallop = 1\n        }\n\n        h.minGallop = minGallop // Write back to field\n\n        if len2 == 1 {\n            if len1 <= 0 {\n                return errors.New(\" len1 > 0;\")\n            }\n            dest -= len1\n            cursor1 -= len1\n\n            copy(a[dest+1:dest+1+len1], a[cursor1+1:cursor1+1+len1])\n            a[dest] = tmp[cursor2] // Move first elt of run2 to front of merge\n        } else if len2 == 0 {\n            return errors.New(\"comparison method violates its general contract\")\n        } else {\n            if len1 != 0 {\n                return errors.New(\"len1 == 0;\")\n            }\n\n            if len2 <= 0 {\n                return errors.New(\" len2 > 0;\")\n            }\n\n            copy(a[dest-(len2-1):dest+1], tmp)\n        }\n        return\n    }\n\n    func (h *${timSortHandler}) ensureCapacity(minCapacity int) []${sliceType} {\n        if len(h.tmp) < minCapacity {\n            // Compute smallest power of 2 > minCapacity\n            newSize := minCapacity\n            newSize |= newSize >> 1\n            newSize |= newSize >> 2\n            newSize |= newSize >> 4\n            newSize |= newSize >> 8\n            newSize |= newSize >> 16\n            newSize++\n\n            if newSize < 0 { // Not bloody likely!\n                newSize = minCapacity\n            } else {\n                ns := len(h.a) / 2\n                if ns < newSize {\n                    newSize = ns\n                }\n            }\n\n            h.tmp = make([]${sliceType}, newSize)\n        }\n        return h.tmp\n    }\n    `;\n}\n","import { GeneratorConfig } from './config';\nimport { generate } from './slices-template';\nimport { generateComparable } from './slices-comparable-template';\nimport { generateTimsort } from './slices-timsort-template';\nimport { generateComparableTimsort } from './slices-comparable-timsort-template';\n\nexport { GeneratorConfig } from './config';\n\nexport function generateSourceCode(config: GeneratorConfig): string {\n    let source: string;\n    if (config.acceptLessThan) {\n        if (config.useTimSort) {\n            source = generateTimsort(config);\n        } else {\n            source = generate(config);\n        }\n    } else {\n        if (config.useTimSort) {\n            source = generateComparableTimsort(config);\n        } else {\n            source = generateComparable(config);\n        }\n    }\n    return simpleGoFormat(source);\n}\n\nfunction simpleGoFormat(src: string): string {\n    const [_, ...lines] = src.split('\\n');\n\n    const result = lines.map((line: string) => {\n        line = line.slice(4);\n        const match = line.match(/^( +)/);\n        if (match) {\n            const indent = Math.floor(match[1].length / 4);\n            const space = new Array(indent + 1).join('    ');\n            const tab = new Array(indent + 1).join('\\t');\n            line = line.replace(space, tab);\n        }\n        return line;\n    });\n\n    return result.join('\\n');\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ion-list',[_c('ion-item-group',[_c('ion-list-header',[_c('ion-label',[_vm._v(\"Package/File information\")])],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\"}},[_vm._v(\"Package Name\")]),_c('ion-input',{attrs:{\"value\":_vm.getPackageName},on:{\"ionInput\":function($event){return _vm.onChangePackageName($event)}}})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\"}},[_vm._v(\"Function Prefix\")]),_c('ion-input',{attrs:{\"value\":_vm.getFunctionPrefix},on:{\"ionInput\":function($event){return _vm.onChangeFunctionPrefix($event)}}})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\"}},[_vm._v(\"Function Suffix\")]),_c('ion-input',{attrs:{\"value\":_vm.getFunctionSuffix},on:{\"ionInput\":function($event){return _vm.onChangeFunctionSuffix($event)}}})],1)],1),_c('ion-item-group',[_c('ion-list-header',[_c('ion-label',[_vm._v(\"Generator Option\")])],1),_c('ion-item',[_c('ion-label',[_vm._v(\"Use Primitive Type\")]),_c('ion-toggle',{attrs:{\"slot\":\"end\",\"color\":\"primary\",\"checked\":_vm.doesUsePrimitiveType},on:{\"ionChange\":function($event){return _vm.onChangeType($event)}},slot:\"end\"})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\",\"color\":_vm.doesUsePrimitiveType ? 'medium' : undefined}},[_vm._v(\"Slice Types\")]),_c('ion-input',{attrs:{\"value\":_vm.getSliceType,\"disabled\":_vm.doesUsePrimitiveType},on:{\"ionChange\":function($event){return _vm.onChangeSliceType($event)}}})],1),_c('ion-item',[_c('ion-label',{attrs:{\"position\":\"stacked\",\"color\":!_vm.doesUsePrimitiveType ? 'medium' : undefined}},[_vm._v(\"Primitive Type\")]),_c('ion-select',{attrs:{\"value\":_vm.getPrimitiveSliceType,\"okText\":\"Okay\",\"cancelText\":\"Dismiss\",\"disabled\":!_vm.doesUsePrimitiveType},on:{\"ionChange\":function($event){return _vm.onChangePrimitiveSliceType($event)}}},[_c('ion-select-option',{attrs:{\"value\":\"int\"}},[_vm._v(\"int\")]),_c('ion-select-option',{attrs:{\"value\":\"uint\"}},[_vm._v(\"uint\")]),_c('ion-select-option',{attrs:{\"value\":\"byte\"}},[_vm._v(\"byte\")]),_c('ion-select-option',{attrs:{\"value\":\"rune\"}},[_vm._v(\"rune\")]),_c('ion-select-option',{attrs:{\"value\":\"int8\"}},[_vm._v(\"int8\")]),_c('ion-select-option',{attrs:{\"value\":\"uint8\"}},[_vm._v(\"uint8\")]),_c('ion-select-option',{attrs:{\"value\":\"int16\"}},[_vm._v(\"int16\")]),_c('ion-select-option',{attrs:{\"value\":\"uint16\"}},[_vm._v(\"uint16\")]),_c('ion-select-option',{attrs:{\"value\":\"int32\"}},[_vm._v(\"int32\")]),_c('ion-select-option',{attrs:{\"value\":\"uint32\"}},[_vm._v(\"uint32\")]),_c('ion-select-option',{attrs:{\"value\":\"int64\"}},[_vm._v(\"int64\")]),_c('ion-select-option',{attrs:{\"value\":\"uint64\"}},[_vm._v(\"uint64\")]),_c('ion-select-option',{attrs:{\"value\":\"float32\"}},[_vm._v(\"float32\")]),_c('ion-select-option',{attrs:{\"value\":\"float64\"}},[_vm._v(\"float64\")])],1)],1),_c('ion-item',[_c('ion-label',[_vm._v(\"Accept LessThan function\")]),_c('ion-toggle',{attrs:{\"slot\":\"end\",\"checked\":_vm.doesAcceptLessThan,\"color\":\"primary\"},on:{\"ionChange\":function($event){return _vm.onChangeAcceptLessThan($event)}},slot:\"end\"})],1),_c('ion-item',[_c('ion-label',[_vm._v(\"Use TimSort\")]),_c('ion-toggle',{attrs:{\"slot\":\"end\",\"color\":\"primary\",\"checked\":_vm.doesUseTimSort},on:{\"ionChange\":function($event){return _vm.onChangeUseTimSort($event)}},slot:\"end\"})],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Emit } from 'vue-property-decorator';\nimport { GeneratorConfig } from '../codegen';\n\n@Component\nexport default class ConfigPanel extends Vue {\n  @Prop() public value!: GeneratorConfig;\n\n  private pakcageName = this.value.packageName;\n  private functionPrefix = this.value.funcPrefix;\n  private functionSuffix = this.value.funcSuffix;\n  private sliceType = this.value.sliceType;\n  private primitiveSliceType = 'int';\n  private usePrimitiveType = false;\n  private acceptLessThan = this.value.acceptLessThan;\n  private useTimSort = this.value.useTimSort;\n\n  get getPackageName(): string {\n    return this.pakcageName;\n  }\n\n  get getFunctionPrefix(): string {\n    return this.functionPrefix;\n  }\n\n  get getFunctionSuffix(): string {\n    return this.functionSuffix;\n  }\n\n  get getSliceType(): string {\n    return this.sliceType;\n  }\n\n  get doesUsePrimitiveType(): boolean {\n    return this.usePrimitiveType;\n  }\n\n  get getPrimitiveSliceType(): string {\n    return this.primitiveSliceType;\n  }\n\n  get doesAcceptLessThan(): boolean {\n    return this.acceptLessThan;\n  }\n\n  get doesUseTimSort(): boolean {\n    return this.useTimSort;\n  }\n\n  public onChangePackageName(event: any) {\n    this.pakcageName = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeFunctionPrefix(event: any) {\n    this.functionPrefix = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeFunctionSuffix(event: any) {\n    this.functionSuffix = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeType(event: any) {\n    this.usePrimitiveType = event.target.checked;\n    this.emitConfig();\n  }\n\n  public onChangeSliceType(event: any) {\n    this.sliceType = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangePrimitiveSliceType(event: any) {\n    this.primitiveSliceType = event.target.value;\n    this.emitConfig();\n  }\n\n  public onChangeAcceptLessThan(event: any) {\n    this.acceptLessThan = event.target.checked;\n    this.emitConfig();\n  }\n\n  public onChangeUseTimSort(event: any) {\n    this.useTimSort = event.target.checked;\n    this.emitConfig();\n  }\n\n  @Emit()\n  public input(value: GeneratorConfig) {\n  }\n\n  private emitConfig() {\n    const sliceType = this.usePrimitiveType ? this.primitiveSliceType : this.sliceType;\n    const config = {\n      packageName: this.pakcageName,\n      funcPrefix: this.functionPrefix,\n      funcSuffix: this.functionSuffix,\n      sliceType,\n      acceptLessThan: this.acceptLessThan,\n      useTimSort: this.useTimSort,\n    };\n    this.input(config);\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/ts-loader/index.js??ref--12-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConfigPanel.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/ts-loader/index.js??ref--12-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConfigPanel.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ConfigPanel.vue?vue&type=template&id=747d5987&\"\nimport script from \"./ConfigPanel.vue?vue&type=script&lang=ts&\"\nexport * from \"./ConfigPanel.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Prop, Emit } from 'vue-property-decorator';\nimport { generateSourceCode, GeneratorConfig } from './codegen';\n\nimport ConfigPanel from './components/ConfigPanel.vue';\n\n@Component({\n  components: {\n    ConfigPanel,\n  },\n})\nexport default class App extends Vue {\n  private config: GeneratorConfig = {\n    packageName: 'main',\n    funcPrefix: 'MyStruct',\n    funcSuffix: '',\n    sliceType: '*MyStruct',\n    acceptLessThan: true,\n    useTimSort: false,\n  };\n\n  private goCode(): string {\n    return generateSourceCode(this.config);\n  }\n\n  private updated() {\n    const elem = document.getElementById('goCode') as HTMLElement;\n    elem.innerHTML = this.escapeHtml(this.goCode());\n    const win = window as any;\n    win.Prism.highlightAll();\n  }\n\n  private escapeHtml(content: string) {\n    return content\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;');\n  }\n}\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/ts-loader/index.js??ref--12-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/ts-loader/index.js??ref--12-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=7bb58f88&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","/* tslint:disable:no-console */\n\nimport { register } from 'register-service-worker';\n\nif (process.env.NODE_ENV === 'production') {\n  register(`${process.env.BASE_URL}service-worker.js`, {\n    ready() {\n      console.log(\n        'App is being served from cache by a service worker.\\n' +\n        'For more details, visit https://goo.gl/AFskqB',\n      );\n    },\n    registered() {\n      console.log('Service worker has been registered.');\n    },\n    cached() {\n      console.log('Content has been cached for offline use.');\n    },\n    updatefound() {\n      console.log('New content is downloading.');\n    },\n    updated() {\n      console.log('New content is available; please refresh.');\n    },\n    offline() {\n      console.log('No internet connection found. App is running in offline mode.');\n    },\n    error(error) {\n      console.error('Error during service worker registration:', error);\n    },\n  });\n}\n","import Vue from 'vue';\nimport App from './App.vue';\nimport './registerServiceWorker';\n\nVue.config.productionTip = false;\nVue.config.ignoredElements = [\n  'ion-app',\n  'ion-page',\n  'ion-header',\n  'ion-toolbar',\n  'ion-title',\n  'ion-content',\n  'ion-button',\n  'ion-icon',\n  'ion-menu-toggle',\n  'ion-item',\n  'ion-label',\n  'ion-checkbox',\n  'ion-toggle',\n  'ion-item-divider',\n  'ion-item-group',\n  'ion-buttons',\n  'ion-select',\n  'ion-select-option',\n  'ion-input',\n  'ion-list-header',\n  'ion-list',\n  'ion-split-pane',\n  'ion-menu',\n];\n\nnew Vue({\n  render: (h) => h(App),\n}).$mount('#app');\n"],"sourceRoot":""}