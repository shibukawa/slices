// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package small

import "sort"

// IntLessThan is Delegate type that sorting uses as a comparator
type IntLessThan func(a, b int) bool

// IntSort sorts an array using the provided comparator
func IntSort(a []int, lt IntLessThan) (err error) {
	sort.Slice(a, func(i, j int) bool {
		return lt(a[i], a[j])
	})
	return nil
}

// IntBinarySearch returns first index i that satisfies slices[i] <= item.
func IntBinarySearch(sorted []int, item int, lt IntLessThan) int {
	// Define f(-1) == false and f(n) == true.
	// Invariant: f(i-1) == false, f(j) == true.
	i, j := 0, len(sorted)-1
	for i < j {
		h := int(uint(i+j) >> 1) // avoid overflow when computing h
		// i â‰¤ h < j
		if lt(sorted[h], item) {
			i = h + 1 // preserves f(i-1) == false
		} else {
			j = h // preserves f(j) == true
		}
	}
	// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.
	return i
}

// IntIndexOf returns index of item. If item is not in a sorted slice, it returns -1.
func IntIndexOf(sorted []int, item int, lt IntLessThan) int {
	i := IntBinarySearch(sorted, item, lt)
	if !lt(sorted[i], item) && !lt(item, sorted[i]) {
		return i
	}
	return -1
}

// IntContains returns true if item is in a sorted slice. Otherwise false.
func IntContains(sorted []int, item int, lt IntLessThan) bool {
	i := IntBinarySearch(sorted, item, lt)
	return !lt(sorted[i], item) && !lt(item, sorted[i])
}

// IntInsert inserts item in correct position and returns a sorted slice.
func IntInsert(sorted []int, item int, lt IntLessThan) []int {
	i := IntBinarySearch(sorted, item, lt)
	if i == len(sorted)-1 && lt(sorted[i], item) {
		return append(sorted, item)
	}
	return append(sorted[:i], append([]int{item}, sorted[i:]...)...)
}

// IntRemove removes item in a sorted slice.
func IntRemove(sorted []int, item int, lt IntLessThan) []int {
	i := IntBinarySearch(sorted, item, lt)
	if !lt(sorted[i], item) && !lt(item, sorted[i]) {
		return IntRemoveAt(sorted, i)
	}
	return sorted
}

// IntRemoveAt removes item in a slice.
func IntRemoveAt(sorted []int, i int) []int {
	return append(sorted[:i], sorted[i+1:]...)
}

// IntIterateOver iterates over input sorted slices and calls callback with each items in ascendant order.
func IntIterateOver(lt IntLessThan, callback func(item int, srcIndex int), sorted ...[]int) {
	sourceSlices := make([][]int, 0, len(sorted))
	for _, src := range sorted {
		if len(src) > 0 {
			sourceSlices = append(sourceSlices, src)
		}
	}
	sourceSliceCount := len(sourceSlices)
	if sourceSliceCount == 0 {
		return
	} else if sourceSliceCount == 1 {
		for i, value := range sourceSlices[0] {
			callback(value, i)
		}
		return
	}
	indexes := make([]int, sourceSliceCount)
	sliceIndex := make([]int, sourceSliceCount)
	for i := range sourceSlices {
		sliceIndex[i] = i
	}
	index := 0
	for {
		minSlice := 0
		minItem := sourceSlices[0][indexes[0]]
		for i := 1; i < sourceSliceCount; i++ {
			if lt(sourceSlices[i][indexes[i]], minItem) {
				minSlice = i
				minItem = sourceSlices[i][indexes[i]]
			}
		}
		callback(minItem, sliceIndex[minSlice])
		index++
		indexes[minSlice]++
		if indexes[minSlice] == len(sourceSlices[minSlice]) {
			sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)
			indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)
			sliceIndex = append(sliceIndex[:minSlice], sliceIndex[minSlice+1:]...)
			sourceSliceCount--
			if len(sourceSlices) == 1 {
				slice := sourceSlices[0]
				for i := indexes[0]; i < len(slice); i++ {
					callback(slice[i], sliceIndex[0])
				}
				return
			}
		}
	}
}

// IntUnion unions sorted slices and returns new slices.
func IntUnion(lt IntLessThan, sorted ...[]int) []int {
	length := 0
	sourceSlices := make([][]int, 0, len(sorted))
	for _, src := range sorted {
		if len(src) > 0 {
			length += len(src)
			sourceSlices = append(sourceSlices, src)
		}
	}
	if length == 0 {
		return nil
	} else if len(sourceSlices) == 1 {
		return sourceSlices[0]
	}
	result := make([]int, length)
	sourceSliceCount := len(sourceSlices)
	indexes := make([]int, sourceSliceCount)
	index := 0
	for {
		minSlice := 0
		minItem := sourceSlices[0][indexes[0]]
		for i := 1; i < sourceSliceCount; i++ {
			if lt(sourceSlices[i][indexes[i]], minItem) {
				minSlice = i
				minItem = sourceSlices[i][indexes[i]]
			}
		}
		result[index] = minItem
		index++
		indexes[minSlice]++
		if indexes[minSlice] == len(sourceSlices[minSlice]) {
			sourceSlices = append(sourceSlices[:minSlice], sourceSlices[minSlice+1:]...)
			indexes = append(indexes[:minSlice], indexes[minSlice+1:]...)
			sourceSliceCount--
			if len(sourceSlices) == 1 {
				copy(result[index:], sourceSlices[0][indexes[0]:])
				return result
			}
		}
	}
}
